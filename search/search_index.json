{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Pydo? \u00b6 pydo is a free software command line task manager built with Python and SQLAlchemy . pydo scales to fit your workflow. Use it as a simple app that captures tasks, shows you the list, and removes tasks from that list. Leverage its capabilities though, and it becomes a sophisticated data query tool that can help you stay organized, and get through your work. Why another CLI Task Manager? \u00b6 Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are several issues with how it handles recurrence . It doesn't have friendly task identifiers. There is no way of accessing the task time tracking from the python library. And lacks the following features: Native support for Kanban or Scrum. Task estimations. Task criteria validation . Easy report creation. Easy way to manage the split of a task in subtasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need. A quick demonstration \u00b6 Let's see pydo in action. We'll first add a few tasks to our list. pydo add Buy milk pydo add Buy eggs pydo add Bake cake Now let's see the list. pydo list ID Title ---- --------- d Bake cake s Buy eggs a Buy milk Suppose we bought our ingredients and wish to mark the first two tasks as done. pydo a done pydo s done pydo list ID Title ---- --------- d Bake cake Those are the first three features, the add , list and done commands, but they represent all you really need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the simple three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and many more. Installation \u00b6 Until we improve the install method do: pip3 install git+git://github.com/lyz-code/pydo mkdir ~/.local/share/pydo touch ~/.local/share/pydo/main.db pydo install What's next? \u00b6 Probably the most important next step is to simply start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to modify your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not really helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. Welcome to pydo .","title":"Introduction"},{"location":"#what-is-pydo","text":"pydo is a free software command line task manager built with Python and SQLAlchemy . pydo scales to fit your workflow. Use it as a simple app that captures tasks, shows you the list, and removes tasks from that list. Leverage its capabilities though, and it becomes a sophisticated data query tool that can help you stay organized, and get through your work.","title":"What is Pydo?"},{"location":"#why-another-cli-task-manager","text":"Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are several issues with how it handles recurrence . It doesn't have friendly task identifiers. There is no way of accessing the task time tracking from the python library. And lacks the following features: Native support for Kanban or Scrum. Task estimations. Task criteria validation . Easy report creation. Easy way to manage the split of a task in subtasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need.","title":"Why another CLI Task Manager?"},{"location":"#a-quick-demonstration","text":"Let's see pydo in action. We'll first add a few tasks to our list. pydo add Buy milk pydo add Buy eggs pydo add Bake cake Now let's see the list. pydo list ID Title ---- --------- d Bake cake s Buy eggs a Buy milk Suppose we bought our ingredients and wish to mark the first two tasks as done. pydo a done pydo s done pydo list ID Title ---- --------- d Bake cake Those are the first three features, the add , list and done commands, but they represent all you really need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the simple three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and many more.","title":"A quick demonstration"},{"location":"#installation","text":"Until we improve the install method do: pip3 install git+git://github.com/lyz-code/pydo mkdir ~/.local/share/pydo touch ~/.local/share/pydo/main.db pydo install","title":"Installation"},{"location":"#whats-next","text":"Probably the most important next step is to simply start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to modify your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not really helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. Welcome to pydo .","title":"What's next?"},{"location":"basic_usage/","text":"All you need to know to use pydo effectively are these four commands ( add , done , del , list ). Add \u00b6 To add a task run: pydo add Improve the pydo manual It is also possible to immediately add tags or projects when creating a task: pydo add Improve the pydo manual pro:task_management +python List \u00b6 To see the open tasks run: pydo list By default, list is the default command, so you can execute pydo alone. Done \u00b6 If you've completed a task, run: pydo done {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the list report. Delete \u00b6 If you no longer need a task, run: pydo del {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the list report. If you are new to pydo , it is recommended that you stop here, go and start to manage your task list for a while. We don't want you to be overwhelmed at a time when you just need a way to organize and get things done. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might just find exactly what you need.","title":"Basic Usage"},{"location":"basic_usage/#add","text":"To add a task run: pydo add Improve the pydo manual It is also possible to immediately add tags or projects when creating a task: pydo add Improve the pydo manual pro:task_management +python","title":"Add"},{"location":"basic_usage/#list","text":"To see the open tasks run: pydo list By default, list is the default command, so you can execute pydo alone.","title":"List"},{"location":"basic_usage/#done","text":"If you've completed a task, run: pydo done {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the list report.","title":"Done"},{"location":"basic_usage/#delete","text":"If you no longer need a task, run: pydo del {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the list report. If you are new to pydo , it is recommended that you stop here, go and start to manage your task list for a while. We don't want you to be overwhelmed at a time when you just need a way to organize and get things done. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might just find exactly what you need.","title":"Delete"},{"location":"configuration/","text":"All configuration is stored in the database. By default, pydo uses a SQLite database in ~/.local/share/pydo/main.db , but you can define another connection with the PYDO_DATABASE_URL environmental variable, such as sqlite:///absolute_path_to_file.md . When you execute pydo install the initial schema is configured. Until we have a better solution , the only way to modify the configuration is to manually edit the config table of the database. You can do so with different programs, but I suggest litecli .","title":"Configuration"},{"location":"dates/","text":"A task does not require a due date, and can simply be a statement of need: pydo add Send Alice a birthday card However this is exactly the kind of task can benefit from having a due date, and perhaps several other dates also. There are several dates that can decorate a task, each with its own meaning and effects. You can choose to use some, all or none of these, but like all pydo features, they are there in case your needs require it, but you do not pay a performance or friction penalty by not using them. The due date \u00b6 Use a optional due task attribute to specify the exact date by which a task must be completed. This corresponds to the last possible moment when the task can be considered on-time. Using our example, we can set the due date to be Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. There is also an overdue report that makes use of the OVERDUE virtual tag, to show you what is already late. If you run the calendar report, your due date will be highlighted on it. What we see here is that Taskwarrior leverages the metadata to drive various features. Several reports will sort by due date, and as we see above, a task that has a due date now belongs on your schedule. Date format \u00b6 pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the following operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Dates"},{"location":"dates/#the-due-date","text":"Use a optional due task attribute to specify the exact date by which a task must be completed. This corresponds to the last possible moment when the task can be considered on-time. Using our example, we can set the due date to be Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. There is also an overdue report that makes use of the OVERDUE virtual tag, to show you what is already late. If you run the calendar report, your due date will be highlighted on it. What we see here is that Taskwarrior leverages the metadata to drive various features. Several reports will sort by due date, and as we see above, a task that has a due date now belongs on your schedule.","title":"The due date"},{"location":"dates/#date-format","text":"pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the following operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Date format"},{"location":"design/","text":"Desing docs \u00b6 Idea on epics, task and subtasks management \u00b6 Change the idea on how we work on the tasks. With something like plan task it opens a editor window where you specify the subtask hierarchy (as many levels as needed), once it closes it creates the tasks and blocks the ones that are not actionable. You can decide to work on the epic (or the parent of all subtasks) or directly on the first available subtask and both will point to the same subtask. Maybe we can use this notation in the editor parser: # [ ] Task title: Task description ## [ ] Subtask title: subtask description Also it's important to define if the tasks at the same level are blocking or paralelizable, so once you mark one as blocked or in review it suggest you to continue with the next available subtask. For example, we could use hte following syntax # [P] Task title: Task description ## [ ] paralelizable Subtask title: subtask description ## [ ] (Blocking) blocking Subtask title: subtask description You define till what level of task (only epic and tasks?) to define the est, ov, fun attributes, the rest will go plain as they are supposed to be done inside the sprint scope In the display we could have something like a parent task fulid field.","title":"Desing docs"},{"location":"design/#desing-docs","text":"","title":"Desing docs"},{"location":"design/#idea-on-epics-task-and-subtasks-management","text":"Change the idea on how we work on the tasks. With something like plan task it opens a editor window where you specify the subtask hierarchy (as many levels as needed), once it closes it creates the tasks and blocks the ones that are not actionable. You can decide to work on the epic (or the parent of all subtasks) or directly on the first available subtask and both will point to the same subtask. Maybe we can use this notation in the editor parser: # [ ] Task title: Task description ## [ ] Subtask title: subtask description Also it's important to define if the tasks at the same level are blocking or paralelizable, so once you mark one as blocked or in review it suggest you to continue with the next available subtask. For example, we could use hte following syntax # [P] Task title: Task description ## [ ] paralelizable Subtask title: subtask description ## [ ] (Blocking) blocking Subtask title: subtask description You define till what level of task (only epic and tasks?) to define the est, ov, fun attributes, the rest will go plain as they are supposed to be done inside the sprint scope In the display we could have something like a parent task fulid field.","title":"Idea on epics, task and subtasks management"},{"location":"estimate/","text":"The estimate optional task attribute registers how many hours do you expect to spend on a task. In the Scrum methodology, assigning time estimate to tasks is a sin. Instead they use story points , which is an dimensionless quantity to compare tasks between themselves. The advantages of using story points is that you are not commiting to do a task in a specified amount of time and that it's easier to estimate if you are going to need more or less time to do a task than an other in relative terms. Once you complete several sprints , this estimate method is said to be more accurate. I've tried using story points in the past, but I find them unintuitive and useless when trying to improve your estimations. But as the estimate keyword accepts any float, you can use it to store story points . To set the estimate of a task use the est or estimate keyword: pydo add Task that takes 5 hours to complete est:5 Right now we only use the estimate for filtering or visualization purposes. But we plan to support reports to do data analysis on the difference between the estimation and the real time required to complete the task, so as to suggest estimation improvements.","title":"Estimate"},{"location":"fulids/","text":"FULID \u00b6 To generate id's that are going to be used in the command line, we are using a variation of the ulids . Usage \u00b6 Create a brand new FULID. \u00b6 The timestamp value (48-bits) is from time.time() with millisecond precision. The randomness value (45-bits) is from os.urandom() . The id value (24-bits) is from a selected character set. >>> import fulid >>> fulid () . new () < fulid ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) > Create the next fulid \u00b6 >>> import fulid >>> fulid () . new ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) < fulid ( '01DWFBFPC4K8MDYBDDBAAAAAAS' ) > Specification \u00b6 Below is the current specification of FULID. 01AN4Z07BY 79KA1307S AAAAAAA |----------| |--------| |------| Timestamp Randomness ID 48bits 9 chars 7 chars Components \u00b6 Timestamp - 48 bit integer - UNIX-time in milliseconds - Won't run out of space 'til the year 10889 AD. Randomness - 45 bits - Cryptographically secure source of randomness, if possible ID - 24 bits - Based on a selected character set selected by the user, by default is asdfghjwer as there are ones that require less finger movement and are not forbidden by ulid. - You can define your own character set, of the length that you want. But they should not be part of the forbidden characters, which by default are ilou|&:;()<>~*@?!$#[]{}\\\\/\\'\" . Sorting \u00b6 The left-most character must be sorted first, and the right-most character sorted last (lexical order). The default ASCII character set must be used. Within the same millisecond, sort order is not guaranteed.","title":"FULID"},{"location":"fulids/#fulid","text":"To generate id's that are going to be used in the command line, we are using a variation of the ulids .","title":"FULID"},{"location":"fulids/#usage","text":"","title":"Usage"},{"location":"fulids/#create-a-brand-new-fulid","text":"The timestamp value (48-bits) is from time.time() with millisecond precision. The randomness value (45-bits) is from os.urandom() . The id value (24-bits) is from a selected character set. >>> import fulid >>> fulid () . new () < fulid ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) >","title":"Create a brand new FULID."},{"location":"fulids/#create-the-next-fulid","text":">>> import fulid >>> fulid () . new ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) < fulid ( '01DWFBFPC4K8MDYBDDBAAAAAAS' ) >","title":"Create the next fulid"},{"location":"fulids/#specification","text":"Below is the current specification of FULID. 01AN4Z07BY 79KA1307S AAAAAAA |----------| |--------| |------| Timestamp Randomness ID 48bits 9 chars 7 chars","title":"Specification"},{"location":"fulids/#components","text":"Timestamp - 48 bit integer - UNIX-time in milliseconds - Won't run out of space 'til the year 10889 AD. Randomness - 45 bits - Cryptographically secure source of randomness, if possible ID - 24 bits - Based on a selected character set selected by the user, by default is asdfghjwer as there are ones that require less finger movement and are not forbidden by ulid. - You can define your own character set, of the length that you want. But they should not be part of the forbidden characters, which by default are ilou|&:;()<>~*@?!$#[]{}\\\\/\\'\" .","title":"Components"},{"location":"fulids/#sorting","text":"The left-most character must be sorted first, and the right-most character sorted last (lexical order). The default ASCII character set must be used. Within the same millisecond, sort order is not guaranteed.","title":"Sorting"},{"location":"priority/","text":"The priority optional task attribute registers how urgent a task is. The parameter allows any integer, but I use from 0 (really low priority) to 5 (really high priority), being 3 the standard medium priority. To set the priority of a task use the pri or priority keyword: pydo add Task with highest priority pri:5 Right now we only use the priority for filtering or visualization purposes. But we plan to support reports that sort the tasks by their urgency . The priority will be one of the main factors to take into account.","title":"Priority"},{"location":"projects/","text":"Once you feel comfortable with the basic usage of pydo , you may want to explore the different features it has to adapt it to your workflow. As the number of tasks starts to increase, it's convenient to group them together to help us with the priorization and visualization. One way of doing so is using projects. A project is an optional category that defines the purpose of a task therefore a task can only have one project . If you feel that a task might have two projects or if you have hierarchical problems with your tasks, you may want to use tags instead. For example, I'd use clean for cleaning tasks, or time_management for pydo developing tasks. To add a project to a task, use the project or pro keyword. pydo add Improve pydo documentation pro:time_management To see all the existing projects, use the projects report: pydo projects Name Tasks Description -------- ------- --------------------- None 3 Tasks without project time_management 1","title":"Projects"},{"location":"related/","text":"If pydo isn't your cup of tea, maybe one of the other free task managers fits the bill: Buku : Store and manage your bookmarks from the command line. CommitTasks : Combination between git commit and todo list. Eureka : CLI tool to input and store ideas without leaving the terminal. Ff : A distributed note taker and task manager. git-pending : Git plugin to list TODO, FIXME, TESTME, DOCME comments in a repository. Org mode : Notes and todo lists powered by an Emacs based plain-text system. Smos : Purely functional semantic tree-based editor (similar to [Org mode]). Taskbook : Tasks, boards & notes for the command-line habitat. Taskell : Command line Kanban board / task management. Taskwarrior : Command line task management. Tasklite : Command line tool built with Haskell and SQLite. Toodles : Project management from the TODO's in your codebase. Tracli : Command line app that tracks your time. Ultralist : Open source task management system for the command line. Unfog : A simple CLI task and time manager. Yokadi : Command line oriented, SQLite powered todo list. Eagle : Minimalistic todo app for command line.","title":"Related"},{"location":"roadmap/","text":"pydo 's initial development has been split into phases. Follow the evolution of each item in the issues page. 0.1.0. Task structure to be able to import from taskwarrior \u00b6 Create the initial infrastructure to import Taskwarrior tasks and do basic operation on them. Define initial program structure. Configuration management. Tasks initial schema: Body. Priority. Due. Estimate. Willpower. Fun. Value. Kanban. Command line friendly IDs system. Projects initial schema. Tags initial schema. Installation. Continuous Integration pipeline. Initial documentation. Recurrence : Repeating. Recurring. Import from taskwarrior. Basic commands: Add task. Complete task. Delete task. Basic reports: List report. Projects report. Tags report. 0.2.0. Make it usable \u00b6 Create the commands to match Taskwarrior functionality. Display task, project, tag information Task attributes: Task wait. Task dependencies and blocks. Task Urgency Commands Modify command Modify tasks Modify projects Modify tags Delete/Complete multiple tasks undo Config Introduce the labels into the config Config print Config add Add task attribute labels in the config log Export to json Search Reports Sort as an argument for the list report sort:priority+ all open waiting recurring query (sql) overdue 0.3.0. Add further functionality \u00b6 Start creating additional value. Start/Stop Create nested subtasks in a way as I use vc Task rotting: task inactivity at x months, task dead at x months. Create validation criteria as some kind of subtasks Add epics Add habits: Positive and negative habits, annotate when they happen and add alarms. Set a max and min recurrence. Serial tasks: recurrent without date, like study book, 25 pages starting value, increment Set up an end of tasks, can be both relative to the due or absolute that will be automatically deleted or completed if it hasn't been acted upon. Create data visualizations for data analysis using Dash: Speed of sprint, week, day with filter by project or tag Average day estimate consumption and evolution, also filter possibility by tag and project. X.X.X Implement Agile functionality \u00b6 Scrum and sprint support Implement a planning command to organize week, or x days in a way di -w does Implement a review command to do similar stuff as taskban does. Week and day overburden, compare due tasks with average est consumption, also fun and willpower to see if you are over commiting. When add task to sprint ask for removal of lowest priority. X.X.X. To implement some time \u00b6 Recommendations: Remove dead or inactive tasks. Change recurrence of periodic tasks. Create Automatic estimate based on 90 percentile of the recurrent tasks Average deviation of est of tasks base on project, tag and est. Alerts: Fun and willpower overconsumption or underconsumption alert. Alert when x% of estimate of task has been completed. Alert when the expected day willpower consumption is greater than the max or is increasing towards the max. Manual estimate override the automatic to turn the previous alarm off. Add real willpower, fun, objective value when done to study the differences between the estimate and the real. Add recurrence on specified days: recur:sun,tue-fri Task done on date, on due date Modify start/stop date Color on reports: check this tabulate issue and the ANSI escape codes . Improve the fulids: Reuse completed tasks number part of the fulid. Mark days as holidays so we can get an idea of remaining holidays and that the recurrence scheduler asks if you want to skip, move after or before the task that would fall there. Add User Defined Attributes support: maybe with metadata in the tasks. Not in our roadmap \u00b6 I'm probably not going to develop the following features, but I'll be glad to accept PR. Synchronization between devices : If you want to synchronize your state between devices, you can either share your SQLite database through git or Syncthing , or use MySQL as your database and configure the connection of the different devices. Possible technologies \u00b6 Show database schema: https://github.com/Alexis-benoist/eralchemy Search: https://github.com/mengzhuo/sqlalchemy-fulltext-search","title":"Roadmap"},{"location":"roadmap/#010-task-structure-to-be-able-to-import-from-taskwarrior","text":"Create the initial infrastructure to import Taskwarrior tasks and do basic operation on them. Define initial program structure. Configuration management. Tasks initial schema: Body. Priority. Due. Estimate. Willpower. Fun. Value. Kanban. Command line friendly IDs system. Projects initial schema. Tags initial schema. Installation. Continuous Integration pipeline. Initial documentation. Recurrence : Repeating. Recurring. Import from taskwarrior. Basic commands: Add task. Complete task. Delete task. Basic reports: List report. Projects report. Tags report.","title":"0.1.0. Task structure to be able to import from taskwarrior"},{"location":"roadmap/#020-make-it-usable","text":"Create the commands to match Taskwarrior functionality. Display task, project, tag information Task attributes: Task wait. Task dependencies and blocks. Task Urgency Commands Modify command Modify tasks Modify projects Modify tags Delete/Complete multiple tasks undo Config Introduce the labels into the config Config print Config add Add task attribute labels in the config log Export to json Search Reports Sort as an argument for the list report sort:priority+ all open waiting recurring query (sql) overdue","title":"0.2.0. Make it usable"},{"location":"roadmap/#030-add-further-functionality","text":"Start creating additional value. Start/Stop Create nested subtasks in a way as I use vc Task rotting: task inactivity at x months, task dead at x months. Create validation criteria as some kind of subtasks Add epics Add habits: Positive and negative habits, annotate when they happen and add alarms. Set a max and min recurrence. Serial tasks: recurrent without date, like study book, 25 pages starting value, increment Set up an end of tasks, can be both relative to the due or absolute that will be automatically deleted or completed if it hasn't been acted upon. Create data visualizations for data analysis using Dash: Speed of sprint, week, day with filter by project or tag Average day estimate consumption and evolution, also filter possibility by tag and project.","title":"0.3.0. Add further functionality"},{"location":"roadmap/#xxx-implement-agile-functionality","text":"Scrum and sprint support Implement a planning command to organize week, or x days in a way di -w does Implement a review command to do similar stuff as taskban does. Week and day overburden, compare due tasks with average est consumption, also fun and willpower to see if you are over commiting. When add task to sprint ask for removal of lowest priority.","title":"X.X.X Implement Agile functionality"},{"location":"roadmap/#xxx-to-implement-some-time","text":"Recommendations: Remove dead or inactive tasks. Change recurrence of periodic tasks. Create Automatic estimate based on 90 percentile of the recurrent tasks Average deviation of est of tasks base on project, tag and est. Alerts: Fun and willpower overconsumption or underconsumption alert. Alert when x% of estimate of task has been completed. Alert when the expected day willpower consumption is greater than the max or is increasing towards the max. Manual estimate override the automatic to turn the previous alarm off. Add real willpower, fun, objective value when done to study the differences between the estimate and the real. Add recurrence on specified days: recur:sun,tue-fri Task done on date, on due date Modify start/stop date Color on reports: check this tabulate issue and the ANSI escape codes . Improve the fulids: Reuse completed tasks number part of the fulid. Mark days as holidays so we can get an idea of remaining holidays and that the recurrence scheduler asks if you want to skip, move after or before the task that would fall there. Add User Defined Attributes support: maybe with metadata in the tasks.","title":"X.X.X. To implement some time"},{"location":"roadmap/#not-in-our-roadmap","text":"I'm probably not going to develop the following features, but I'll be glad to accept PR. Synchronization between devices : If you want to synchronize your state between devices, you can either share your SQLite database through git or Syncthing , or use MySQL as your database and configure the connection of the different devices.","title":"Not in our roadmap"},{"location":"roadmap/#possible-technologies","text":"Show database schema: https://github.com/Alexis-benoist/eralchemy Search: https://github.com/mengzhuo/sqlalchemy-fulltext-search","title":"Possible technologies"},{"location":"tags/","text":"Tags are the other way of clustering your tasks, unlike projects , a task can have several tags. So adding tags is the way to register that several tags share an attribute. For example, I'd use python for tasks related to developing programs with that language, or if you don't use willpower , light could be used to gather easily done tasks. To add a tag to a task, we use the +tag keyword. pydo add Fix pydo install process +python To see all the existing tags, use the tags report: pydo tags Name Tasks Description ------ ------- ------------- python 1","title":"Tags"},{"location":"update/","text":"To update pydo , follow the next steps: pip3 install --upgrade git+git://github.com/lyz-code/pydo pydo install It will apply all the alembic SQL migration scripts and seed the new configuration parameters.","title":"Update"}]}