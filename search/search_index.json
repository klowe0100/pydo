{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Pydo? \u00b6 pydo is a free software command line task manager built with Python and SQLAlchemy . pydo scales to fit your workflow. Use it as a simple app that captures tasks, shows you the list, and removes tasks from that list. Leverage its capabilities though, and it becomes a sophisticated data query tool that can help you stay organized, and get through your work. Documentation Issue tracker Contributing Why another CLI Task Manager? \u00b6 Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are several issues with how it handles recurrence . It doesn't have friendly task identifiers . There is no way of accessing the task time tracking from the python library. And lacks the following features: Native Kanban or Scrum support. Task estimations. Task criteria validation . Easy report creation. Easy way to manage the split of a task in subtasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need. A quick demonstration \u00b6 Let's see pydo in action. We'll first add a few tasks to our list. pydo add Buy milk pydo add Buy eggs pydo add Bake cake Now let's see the open tasks. pydo open ID Title ---- --------- d Bake cake s Buy eggs a Buy milk Suppose we bought our ingredients and wish to mark the first two tasks as done. pydo a done pydo s done pydo ID Title ---- --------- d Bake cake Those are the first three features, the add , open and done commands, but they represent all you really need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the simple three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and many more. Installation \u00b6 Until we improve the install method do: pip3 install git+git://github.com/lyz-code/pydo mkdir ~/.local/share/pydo touch ~/.local/share/pydo/main.db pydo install What's next? \u00b6 Probably the most important next step is to simply start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to modify your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not really helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. If you want to contribute to the project follow this guidelines . Welcome to pydo .","title":"Introduction"},{"location":"#what-is-pydo","text":"pydo is a free software command line task manager built with Python and SQLAlchemy . pydo scales to fit your workflow. Use it as a simple app that captures tasks, shows you the list, and removes tasks from that list. Leverage its capabilities though, and it becomes a sophisticated data query tool that can help you stay organized, and get through your work. Documentation Issue tracker Contributing","title":"What is Pydo?"},{"location":"#why-another-cli-task-manager","text":"Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are several issues with how it handles recurrence . It doesn't have friendly task identifiers . There is no way of accessing the task time tracking from the python library. And lacks the following features: Native Kanban or Scrum support. Task estimations. Task criteria validation . Easy report creation. Easy way to manage the split of a task in subtasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need.","title":"Why another CLI Task Manager?"},{"location":"#a-quick-demonstration","text":"Let's see pydo in action. We'll first add a few tasks to our list. pydo add Buy milk pydo add Buy eggs pydo add Bake cake Now let's see the open tasks. pydo open ID Title ---- --------- d Bake cake s Buy eggs a Buy milk Suppose we bought our ingredients and wish to mark the first two tasks as done. pydo a done pydo s done pydo ID Title ---- --------- d Bake cake Those are the first three features, the add , open and done commands, but they represent all you really need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the simple three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and many more.","title":"A quick demonstration"},{"location":"#installation","text":"Until we improve the install method do: pip3 install git+git://github.com/lyz-code/pydo mkdir ~/.local/share/pydo touch ~/.local/share/pydo/main.db pydo install","title":"Installation"},{"location":"#whats-next","text":"Probably the most important next step is to simply start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to modify your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not really helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. If you want to contribute to the project follow this guidelines . Welcome to pydo .","title":"What's next?"},{"location":"basic_usage/","text":"All you need to know to use pydo effectively are these four commands ( add , done , del , open ). Add \u00b6 To add a task run: pydo add Improve the pydo manual It is also possible to immediately add tags or projects when creating a task: pydo add Improve the pydo manual pro:task_management +python Open \u00b6 To see the open tasks run: pydo open By default, open is the default command, so you can execute pydo alone. Done \u00b6 If you've completed a task, run: pydo done {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report. Delete \u00b6 If you no longer need a task, run: pydo del {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report. If you are new to pydo , it is recommended that you stop here, go and start to manage your task list for a while. We don't want you to be overwhelmed at a time when you just need a way to organize and get things done. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might just find exactly what you need.","title":"Basic Usage"},{"location":"basic_usage/#add","text":"To add a task run: pydo add Improve the pydo manual It is also possible to immediately add tags or projects when creating a task: pydo add Improve the pydo manual pro:task_management +python","title":"Add"},{"location":"basic_usage/#open","text":"To see the open tasks run: pydo open By default, open is the default command, so you can execute pydo alone.","title":"Open"},{"location":"basic_usage/#done","text":"If you've completed a task, run: pydo done {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report.","title":"Done"},{"location":"basic_usage/#delete","text":"If you no longer need a task, run: pydo del {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report. If you are new to pydo , it is recommended that you stop here, go and start to manage your task list for a while. We don't want you to be overwhelmed at a time when you just need a way to organize and get things done. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might just find exactly what you need.","title":"Delete"},{"location":"configuration/","text":"All configuration is stored in the database. By default, pydo uses a SQLite database in ~/.local/share/pydo/main.db , but you can define another connection with the PYDO_DATABASE_URL environmental variable, such as sqlite:///absolute_path_to_file.md . When you execute pydo install the initial schema is configured. Until we have a better solution , the only way to modify the configuration is to manually edit the config table of the database. You can do so with different programs, but I suggest litecli .","title":"Configuration"},{"location":"contributing/","text":"So you've started using pydo and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. The database schema is defined with SQLAlchemy objects and maintained with Alembic . To generate the testing data we use FactoryBoy with Faker . We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Finally, to ensure a quicker pull request resolution, remember to Allow edits from maintainers . Check Developing pydo to get better insights of the internals of the program.","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. The database schema is defined with SQLAlchemy objects and maintained with Alembic . To generate the testing data we use FactoryBoy with Faker . We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Finally, to ensure a quicker pull request resolution, remember to Allow edits from maintainers . Check Developing pydo to get better insights of the internals of the program.","title":"I know how to program in Python"},{"location":"related/","text":"If pydo isn't your cup of tea, maybe one of the other free task managers fits the bill: Buku : Store and manage your bookmarks from the command line. CommitTasks : Combination between git commit and todo list. Eureka : CLI tool to input and store ideas without leaving the terminal. Ff : A distributed note taker and task manager. git-pending : Git plugin to list TODO, FIXME, TESTME, DOCME comments in a repository. Org mode : Notes and todo lists powered by an Emacs based plain-text system. Smos : Purely functional semantic tree-based editor (similar to [Org mode]). Taskbook : Tasks, boards & notes for the command-line habitat. Taskell : Command line Kanban board / task management. Taskwarrior : Command line task management. Tasklite : Command line tool built with Haskell and SQLite. Toodles : Project management from the TODO's in your codebase. Tracli : Command line app that tracks your time. Ultralist : Open source task management system for the command line. Unfog : A simple CLI task and time manager. Yokadi : Command line oriented, SQLite powered todo list. Eagle : Minimalistic todo app for command line.","title":"Related"},{"location":"update/","text":"To update pydo , follow the next steps: pip3 install --upgrade git+git://github.com/lyz-code/pydo pydo install It will apply all the alembic SQL migration scripts and seed the new configuration parameters.","title":"Update"},{"location":"advanced_usage/dates/","text":"A task does not require a due date, and can simply be a statement of need: pydo add Send Alice a birthday card However this is exactly the kind of task can benefit from having a due date. There are several dates that can decorate a task, each with its own meaning and effects. You can choose to use some, all or none of these, but like all pydo features, they are there in case your needs require it, but you do not pay a performance or friction penalty by not using them. The due date \u00b6 Use a optional due task attribute to specify the exact date by which a task must be completed. This corresponds to the last possible moment when the task can be considered on-time. Using our example, we can set the due date to be Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. There is also an overdue report that makes use of the OVERDUE virtual tag, to show you what is already late. If you run the calendar report, your due date will be highlighted on it. What we see here is that Taskwarrior leverages the metadata to drive various features. Several reports will sort by due date, and as we see above, a task that has a due date now belongs on your schedule. To modify the due date of a task use the mod command: pydo mod {{ task_id }} due: {{ new_due_date }} Date format \u00b6 pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the following operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Dates"},{"location":"advanced_usage/dates/#the-due-date","text":"Use a optional due task attribute to specify the exact date by which a task must be completed. This corresponds to the last possible moment when the task can be considered on-time. Using our example, we can set the due date to be Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. There is also an overdue report that makes use of the OVERDUE virtual tag, to show you what is already late. If you run the calendar report, your due date will be highlighted on it. What we see here is that Taskwarrior leverages the metadata to drive various features. Several reports will sort by due date, and as we see above, a task that has a due date now belongs on your schedule. To modify the due date of a task use the mod command: pydo mod {{ task_id }} due: {{ new_due_date }}","title":"The due date"},{"location":"advanced_usage/dates/#date-format","text":"pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the following operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Date format"},{"location":"advanced_usage/estimate/","text":"The estimate optional task attribute registers how many hours do you expect to spend on a task. In the Scrum methodology, assigning time estimate to tasks is a sin. Instead they use story points , which is an dimensionless quantity to compare tasks between themselves. The advantages of using story points is that you are not commiting to do a task in a specified amount of time and that it's easier to estimate if you are going to need more or less time to do a task than an other in relative terms. Once you complete several sprints , this estimate method is said to be more accurate. I've tried using story points in the past, but I find them unintuitive and useless when trying to improve your estimations. But as the estimate keyword accepts any float, you can use it to store story points . To set the estimate of a task use the est or estimate keyword: pydo add Task that takes 5 hours to complete est:5 Right now we only use the estimate for filtering or visualization purposes. But we plan to support reports to do data analysis on the difference between the estimation and the real time required to complete the task, so as to suggest estimation improvements.","title":"Estimate"},{"location":"advanced_usage/export/","text":"Use the export command if you want to dump your database into json format. It can be useful to do migrations of database schema in SQLite as it doesn't support the alter table operation, do operations in your data that are not yet supported in pydo or if you want to extract all your information to import it in another task manager.","title":"Export"},{"location":"advanced_usage/fun/","text":"The fun optional task attribute registers how much light-hearted pleasure, enjoyment, or amusement does the execution of the task gives. As with willpower , if your tasks have this property, it can help you determine the tasks to be done during the sprint and in what order so as not to burn yourself out. To set the value of a task use the fun keyword: pydo add Go hiking fun:4 As with the priority , I use a range of values from 0 to 5 but the parameter allows any integer.","title":"Fun"},{"location":"advanced_usage/objective_value/","text":"The value optional task attribute registers how much you feel this task is going to help you achieve a specific goal. It can be associated with Scrum business value . Business value is an horrendous capitalist term with a lot of implications, therefore we've shorten it to value . If you've categorized your tasks in projects , each one probably has one or several main objectives. If your tasks have this property, it can help you priorize which ones need to be done first, or measure the difference in value between sprints. To set the value of a task use the vl or value keyword: pydo add Task that takes 5 hours to complete value:5 As with the priority , I use a range of values from 0 (it doesn't get me closer to the objective at all) to 5 (it's a critical advance towards the goal) but the parameter allows any integer.","title":"Value"},{"location":"advanced_usage/priority/","text":"The priority optional task attribute registers how urgent a task is. The parameter allows any integer, but I use from 0 (really low priority) to 5 (really high priority), being 3 the standard medium priority. To set the priority of a task use the pri or priority keyword: pydo add Task with highest priority pri:5 Right now we only use the priority for filtering or visualization purposes. But we plan to support reports that sort the tasks by their urgency . The priority will be one of the main factors to take into account.","title":"Priority"},{"location":"advanced_usage/projects/","text":"Once you feel comfortable with the basic usage of pydo , you may want to explore the different features it has to adapt it to your workflow. As the number of tasks starts to increase, it's convenient to group them together to help us with the priorization and visualization. One way of doing so is using projects. A project is an optional category that defines the purpose of a task therefore a task can only have one project . If you feel that a task might have two projects or if you have hierarchical problems with your tasks, you may want to use tags instead. For example, I'd use clean for cleaning tasks, or time_management for pydo developing tasks. To add a project to a task, use the project or pro keyword. pydo add Improve pydo documentation pro:time_management To see all the existing projects, use the projects report: pydo projects Name Tasks Description -------- ------- --------------------- None 3 Tasks without project time_management 1 To modify a task project use the mod command: pydo mod {{ task_id }} pro:new_project","title":"Projects"},{"location":"advanced_usage/recurrence/","text":"Recurrence \u00b6 Recurrence is used to create tasks periodically, such as paying the rent or mowing the lawn. There are two types of recurrence: Recurring: Task which needs to be done every specified period of time, like day, week, etc. It doesn't matter when you complete the task, the next one will be created based on the original due date. Repeating: When this task gets completed or deleted, a duplicate will be created with the specified time offset from the closing date. I.e. subsequent tasks get delayed (e.g. mowing the lawn). pydo implements recurrence with the creation of two kind of tasks: parent and children. The first one holds the template for the second. So each time a child is completed or deleted, the parent attributes are copied and the due date is set according to the recurrence type. pydo will only maintain one children per parent, so it won't create new tasks until the existent is either completed or deleted. Furthermore, it will create only the next actionable task. So if from the last completed children you've missed 3 tasks, those won't be created. Create a recurring or repeating task. \u00b6 To create a recurrent or repeating task, the recurrence time must be set under the rec or rep attribute. That attribute must match the pytho date format. pydo add Pay the rent due:1st rec:1mo pydo add Mow the lawn due:today rep:20d Once they are created, the children will show in the open report, but not the parent. $: pydo ID Title Due ---- ------------- ---------------- f Mow the lawn 2020 -05-03 14 :36 s Pay the rent 2020 -05-03 14 :29 The parent can be seen with the repeating and recurring reports. $: pydo repeating ID Title Recurrence Due ---- ------------- ------------ ---------------- d Mown the lawn 20d 2020 -05-03 14 :36 $: pydo recurring ID Title Recurrence Due ---- ------------ ------------ ---------------- a Pay the rent 1mo 2020 -05-03 14 :29 Completing or deleting a repeating task \u00b6 If you complete or delete the children of a recurrent or repeating task, the next child will be spawned. But if you wish to delete or complete the parent so no further children gets created, you can do either by calling done or del with the parent task id, or with the -p argument with the child id. The advantage of the second method is that you don't need to know the parent id, and it will close both parent and children $: pydo del -p f $: pydo ID Title Due ---- ------------ ---------------- s Pay the rent 2020 -05-03 14 :29 Modifying a recurring task \u00b6 If changes are made in a child task, those changes wont be propagated to the following children, so If you want to make changes permanent, you need to modify the parent either using the parent task id or using mod -p with the children id. Freeze a parent task \u00b6 If you need to temporary pause the creation of new children you can freeze the parent task either with it's id or with freeze -p using the children id. Frozen tasks will appear in the frozen report. To resume the children creation use the unfreeze command.","title":"Recurrence"},{"location":"advanced_usage/recurrence/#recurrence","text":"Recurrence is used to create tasks periodically, such as paying the rent or mowing the lawn. There are two types of recurrence: Recurring: Task which needs to be done every specified period of time, like day, week, etc. It doesn't matter when you complete the task, the next one will be created based on the original due date. Repeating: When this task gets completed or deleted, a duplicate will be created with the specified time offset from the closing date. I.e. subsequent tasks get delayed (e.g. mowing the lawn). pydo implements recurrence with the creation of two kind of tasks: parent and children. The first one holds the template for the second. So each time a child is completed or deleted, the parent attributes are copied and the due date is set according to the recurrence type. pydo will only maintain one children per parent, so it won't create new tasks until the existent is either completed or deleted. Furthermore, it will create only the next actionable task. So if from the last completed children you've missed 3 tasks, those won't be created.","title":"Recurrence"},{"location":"advanced_usage/recurrence/#create-a-recurring-or-repeating-task","text":"To create a recurrent or repeating task, the recurrence time must be set under the rec or rep attribute. That attribute must match the pytho date format. pydo add Pay the rent due:1st rec:1mo pydo add Mow the lawn due:today rep:20d Once they are created, the children will show in the open report, but not the parent. $: pydo ID Title Due ---- ------------- ---------------- f Mow the lawn 2020 -05-03 14 :36 s Pay the rent 2020 -05-03 14 :29 The parent can be seen with the repeating and recurring reports. $: pydo repeating ID Title Recurrence Due ---- ------------- ------------ ---------------- d Mown the lawn 20d 2020 -05-03 14 :36 $: pydo recurring ID Title Recurrence Due ---- ------------ ------------ ---------------- a Pay the rent 1mo 2020 -05-03 14 :29","title":"Create a recurring or repeating task."},{"location":"advanced_usage/recurrence/#completing-or-deleting-a-repeating-task","text":"If you complete or delete the children of a recurrent or repeating task, the next child will be spawned. But if you wish to delete or complete the parent so no further children gets created, you can do either by calling done or del with the parent task id, or with the -p argument with the child id. The advantage of the second method is that you don't need to know the parent id, and it will close both parent and children $: pydo del -p f $: pydo ID Title Due ---- ------------ ---------------- s Pay the rent 2020 -05-03 14 :29","title":"Completing or deleting a repeating task"},{"location":"advanced_usage/recurrence/#modifying-a-recurring-task","text":"If changes are made in a child task, those changes wont be propagated to the following children, so If you want to make changes permanent, you need to modify the parent either using the parent task id or using mod -p with the children id.","title":"Modifying a recurring task"},{"location":"advanced_usage/recurrence/#freeze-a-parent-task","text":"If you need to temporary pause the creation of new children you can freeze the parent task either with it's id or with freeze -p using the children id. Frozen tasks will appear in the frozen report. To resume the children creation use the unfreeze command.","title":"Freeze a parent task"},{"location":"advanced_usage/tags/","text":"Tags are the other way of clustering your tasks, unlike projects , a task can have several tags. So adding tags is the way to register that several tags share an attribute. For example, I'd use python for tasks related to developing programs with that language, or if you don't use willpower , light could be used to gather easily done tasks. To add a tag to a task, we use the +tag keyword. pydo add Fix pydo install process +python To see all the existing tags, use the tags report: pydo tags Name Tasks Description ------ ------- ------------- python 1 To add a tag to an existing task or to remove one, use the mod command. pydo mod {{ task_id }} +new_tag pydo mod {{ task_id }} -existing_tag","title":"Tags"},{"location":"advanced_usage/willpower/","text":"The willpower optional task attribute registers how much energy the execution of the task consumes. Understanding energy as physical or mental energy. For example, solving a complex programming problem, doing long boring tasks or running a marathon have high willpower value, meanwhile watering the plants, going for a walk or to the cinema have a low value. If your tasks have this property, it can help you determine the tasks to be done during the sprint and in what order so as not to burn yourself out. Or to analyze which tasks can be candidates for automation or habit building. To set the value of a task use the wp or willpower keyword: pydo add Add recurrence support to pydo willpower:4 As with the priority , I use a range of values from 0 to 5 but the parameter allows any integer.","title":"Willpower"},{"location":"developing/database_schema/","text":"The schema is defined in the models.py file through SQLAlchemy objects. To visualize the schema we've used wwwsqldesigner through their hosted instance . We load the database_schema.xml to modify it and save it back as xml in the repo.","title":"Database Schema"},{"location":"developing/fulids/","text":"One issue I had when using taskwarrior is that it uses long static UUIDs and short dynamic ids to identify the tasks. The long ones are too cumbersome to use while executing commands and the short ones change, so you may end up doing changes on the wrong task. Friendly Id's aim to solve this problem by generating unique long ids that can be shortened to the minimum amount of characters chosen from a specific set. This set was created with the intention to minimize the finger movements in the keyboard therefore improving the speed and usability. To generate id's that are going to be used in the command line, we are using a variation of the ulids . Specification \u00b6 We took the ulid definition but tweaked to specify the friendly characters. Below is the current specification of FULID. 01AN4Z07BY 79KA1307S AAAAAAA |----------| |--------| |------| Timestamp Randomness ID 48bits 9 chars 7 chars Components \u00b6 Timestamp - 48 bit integer. - UNIX-time in milliseconds. - Won't run out of space 'til the year 10889 AD. Randomness - 45 bits. - Cryptographically secure source of randomness, if possible. ID - 24 bits. - Based on a selected character set selected by the user, by default is asdfghjwer as there are ones that require less finger movement and are not forbidden by ulid. - You can define your own character set, of the length that you want. But they should not be part of the forbidden characters, which by default are ilou|&:;()<>~*@?!$#[]{}\\\\/\\'\" . Sorting \u00b6 The left-most character must be sorted first, and the right-most character sorted last (lexical order). The default ASCII character set must be used. Within the same millisecond, sort order is not guaranteed. Usage \u00b6 Create a brand new FULID. \u00b6 The timestamp value (48-bits) is from time.time() with millisecond precision. The randomness value (45-bits) is from os.urandom() . The id value (24-bits) is from a selected character set. >>> import fulid >>> fulid () . new () < fulid ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) > Create the next fulid \u00b6 >>> import fulid >>> fulid () . new ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) < fulid ( '01DWFBFPC4K8MDYBDDBAAAAAAS' ) >","title":"Friendly IDs"},{"location":"developing/fulids/#specification","text":"We took the ulid definition but tweaked to specify the friendly characters. Below is the current specification of FULID. 01AN4Z07BY 79KA1307S AAAAAAA |----------| |--------| |------| Timestamp Randomness ID 48bits 9 chars 7 chars","title":"Specification"},{"location":"developing/fulids/#components","text":"Timestamp - 48 bit integer. - UNIX-time in milliseconds. - Won't run out of space 'til the year 10889 AD. Randomness - 45 bits. - Cryptographically secure source of randomness, if possible. ID - 24 bits. - Based on a selected character set selected by the user, by default is asdfghjwer as there are ones that require less finger movement and are not forbidden by ulid. - You can define your own character set, of the length that you want. But they should not be part of the forbidden characters, which by default are ilou|&:;()<>~*@?!$#[]{}\\\\/\\'\" .","title":"Components"},{"location":"developing/fulids/#sorting","text":"The left-most character must be sorted first, and the right-most character sorted last (lexical order). The default ASCII character set must be used. Within the same millisecond, sort order is not guaranteed.","title":"Sorting"},{"location":"developing/fulids/#usage","text":"","title":"Usage"},{"location":"developing/fulids/#create-a-brand-new-fulid","text":"The timestamp value (48-bits) is from time.time() with millisecond precision. The randomness value (45-bits) is from os.urandom() . The id value (24-bits) is from a selected character set. >>> import fulid >>> fulid () . new () < fulid ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) >","title":"Create a brand new FULID."},{"location":"developing/fulids/#create-the-next-fulid","text":">>> import fulid >>> fulid () . new ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) < fulid ( '01DWFBFPC4K8MDYBDDBAAAAAAS' ) >","title":"Create the next fulid"}]}