{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Pydo? \u00b6 pydo is a free software command line task manager built with Python and SQLAlchemy . pydo scales to fit your workflow. Use it as a simple app that captures tasks, shows you the list, and removes tasks from that list. Leverage its capabilities though, and it becomes a sophisticated data query tool that can help you stay organized, and get through your work. Documentation Issue tracker Contributing Why another CLI Task Manager? \u00b6 Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are several issues with how it handles recurrence . It doesn't have friendly task identifiers . There is no way of accessing the task time tracking from the python library. And lacks the following features: Native Kanban or Scrum support. Task estimations. Task criteria validation . Easy report creation. Easy way to manage the split of a task in subtasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need. A quick demonstration \u00b6 Let's see pydo in action. We'll first add a few tasks to our list. pydo add Buy milk pydo add Buy eggs pydo add Bake cake Now let's see the open tasks. pydo open ID Title ---- --------- d Bake cake s Buy eggs a Buy milk Suppose we bought our ingredients and wish to mark the first two tasks as done. pydo a done pydo s done pydo ID Title ---- --------- d Bake cake Those are the first three features, the add , open and done commands, but they represent all you really need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the simple three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and many more. Installation \u00b6 Until we improve the install method do: pip3 install git+git://github.com/lyz-code/pydo mkdir ~/.local/share/pydo touch ~/.local/share/pydo/main.db pydo install What's next? \u00b6 Probably the most important next step is to simply start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to modify your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not really helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. If you want to contribute to the project follow this guidelines . Welcome to pydo .","title":"Introduction"},{"location":"#what-is-pydo","text":"pydo is a free software command line task manager built with Python and SQLAlchemy . pydo scales to fit your workflow. Use it as a simple app that captures tasks, shows you the list, and removes tasks from that list. Leverage its capabilities though, and it becomes a sophisticated data query tool that can help you stay organized, and get through your work. Documentation Issue tracker Contributing","title":"What is Pydo?"},{"location":"#why-another-cli-task-manager","text":"Taskwarrior has been the gold standard for CLI task managers so far. However, It has the following inconveniences: It uses a plaintext file as data storage. It stores the data in a non standard way in different files. It's written in C, which I don't speak. It's development has come to code maintenance only . There are several issues with how it handles recurrence . It doesn't have friendly task identifiers . There is no way of accessing the task time tracking from the python library. And lacks the following features: Native Kanban or Scrum support. Task estimations. Task criteria validation . Easy report creation. Easy way to manage the split of a task in subtasks. Most of the above points can be addressed through the Taskwarrior plugin system or udas , but sometimes it's difficult to access the data or as the database grows, the performance drops so quick that it makes them unusable. tasklite is a promising project that tackles most of the points above. But as it's written in Haskel , I won't be able to add support for the features I need.","title":"Why another CLI Task Manager?"},{"location":"#a-quick-demonstration","text":"Let's see pydo in action. We'll first add a few tasks to our list. pydo add Buy milk pydo add Buy eggs pydo add Bake cake Now let's see the open tasks. pydo open ID Title ---- --------- d Bake cake s Buy eggs a Buy milk Suppose we bought our ingredients and wish to mark the first two tasks as done. pydo a done pydo s done pydo ID Title ---- --------- d Bake cake Those are the first three features, the add , open and done commands, but they represent all you really need to know, to get started with pydo . But there are hundreds of other features, so if you learn more, you can do more. It's entirely up to you to choose how you use pydo . Stick to the simple three commands above, or learn about sophisticated agile support, custom reports, user defined metadata and many more.","title":"A quick demonstration"},{"location":"#installation","text":"Until we improve the install method do: pip3 install git+git://github.com/lyz-code/pydo mkdir ~/.local/share/pydo touch ~/.local/share/pydo/main.db pydo install","title":"Installation"},{"location":"#whats-next","text":"Probably the most important next step is to simply start using pydo . Capture your tasks, don't try to remember them. Review your task list to keep it current. Consult your task list to guide your actions. Develop the habit. It doesn't take long until you realize that you might want to modify your workflow. Perhaps you are missing due dates, and need more defined deadlines. Perhaps you need to make greater use of tags to help you filter tasks differently. You'll know if your workflow is not really helping you as much as it could. This is when you might look closer at the docs and the recommended Best Practices. If you want to contribute to the project follow this guidelines . Welcome to pydo .","title":"What's next?"},{"location":"basic_usage/","text":"All you need to know to use pydo effectively are these four commands ( add , done , del , open ). Add \u00b6 To add a task run: pydo add Improve the pydo manual It is also possible to immediately add tags or projects when creating a task: pydo add Improve the pydo manual pro:task_management +python Open \u00b6 To see the open tasks run: pydo open By default, open is the default command, so you can execute pydo alone. Done \u00b6 If you've completed a task, run: pydo done {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report. Delete \u00b6 If you no longer need a task, run: pydo del {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report. If you are new to pydo , it is recommended that you stop here, go and start to manage your task list for a while. We don't want you to be overwhelmed at a time when you just need a way to organize and get things done. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might just find exactly what you need.","title":"Basic Usage"},{"location":"basic_usage/#add","text":"To add a task run: pydo add Improve the pydo manual It is also possible to immediately add tags or projects when creating a task: pydo add Improve the pydo manual pro:task_management +python","title":"Add"},{"location":"basic_usage/#open","text":"To see the open tasks run: pydo open By default, open is the default command, so you can execute pydo alone.","title":"Open"},{"location":"basic_usage/#done","text":"If you've completed a task, run: pydo done {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report.","title":"Done"},{"location":"basic_usage/#delete","text":"If you no longer need a task, run: pydo del {{ task_id }} Where {{ task_id }} is the task id that can be extracted from the open report. If you are new to pydo , it is recommended that you stop here, go and start to manage your task list for a while. We don't want you to be overwhelmed at a time when you just need a way to organize and get things done. When you are comfortable with basic pydo usage, there are many other features you can learn about. While you are not expected to learn all of them, or even find them useful, you might just find exactly what you need.","title":"Delete"},{"location":"configuration/","text":"All configuration is stored in the database. By default, pydo uses a SQLite database in ~/.local/share/pydo/main.db , but you can define another connection with the PYDO_DATABASE_URL environmental variable, such as sqlite:///absolute_path_to_file.md . When you execute pydo install the initial schema is configured. Until we have a better solution , the only way to modify the configuration is to manually edit the config table of the database. You can do so with different programs, but I suggest litecli .","title":"Configuration"},{"location":"contributing/","text":"So you've started using pydo and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. The database schema is defined with SQLAlchemy objects and maintained with Alembic . To generate the testing data we use FactoryBoy with Faker . We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Finally, to ensure a quicker pull request resolution, remember to Allow edits from maintainers . Check Developing pydo to get better insights of the internals of the program.","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. The database schema is defined with SQLAlchemy objects and maintained with Alembic . To generate the testing data we use FactoryBoy with Faker . We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Finally, to ensure a quicker pull request resolution, remember to Allow edits from maintainers . Check Developing pydo to get better insights of the internals of the program.","title":"I know how to program in Python"},{"location":"future_features/","text":"Design documentation for the features I'd love to create in the future. The game of life \u00b6 The goal is to measure the user state to suggest which kind of task are more suitable, raise alerts when the user reaches certain mental or physical states or give insights on the evolution of the user attributes. Domain Model \u00b6 User model \u00b6 We could model the state of a human with the following attributes groups: Mental attributes. Health attributes. Physical attributes. Skills. Traits. I've still not figured out how to vary the total attribute values over the time. Mental attributes \u00b6 Mental Energy: Measures the amount of mental work that you can do before getting fatigued. Vitality: Measures your life force of wanting to do things. For example, for me, dancing or doing work out is a task that increases my vitality, while staying in the couch for 5 hours watching tv shows kills my vitality. Tranquility : Measures the state of being calm, serene, and worry-free. As a side effect it measures the levels of stress and anxiety. Mental load : Measure of the invisible labor involved in managing yourself, a household and your closed ones, which typically falls on women's shoulders. Also sometimes referred to as worry work or cognitive labor , the mental load is about not the physical tasks but rather the overseeing of those tasks. It's being the one in charge of having the never-ending list of to-do items constantly running in your head, remembering what needs to get done and when, delegating tasks to others, and making sure they actually get done. One study describes it as the responsibility of anticipating needs, identifying options for filling them, making decisions, and monitoring progress. Pleasure : Measures the broad class of mental states that we experience as positive, enjoyable, or worth seeking. It includes more specific states such as happiness, entertainment, enjoyment, ecstasy and euphoria. Intelligence : Measures the capacity for logic, understanding, self-awareness, learning, emotional knowledge, reasoning, planning, creativity, critical thinking, and problem-solving. More generally, it's the ability to perceive or infer information, and to keep it as knowledge to be applied towards adaptive behaviors within an environment or context. Logic : Measures the systematic study of valid rules of inference, i.e. the relations that lead to the acceptance of one proposition (the conclusion) on the basis of a set of other propositions (premises). More broadly, logic is the analysis and appraisal of arguments. Understanding : Measures the psychological process related to an abstract or physical object, such as a person, situation, or message whereby one is able to think about it and use concepts to deal adequately with that object. Understanding is a relation between the knower and an object of understanding. Understanding implies abilities and dispositions in relation to an object of knowledge that are enough to support intelligent behavior. Self-awareness : Measures the experience of one's own personality or individuality. While consciousness is being aware of one's environment and body and lifestyle, self-awareness is the recognition of that awareness. Self-awareness is how an individual consciously knows and understands their own character, feelings, motives, and desires. Learning : Measures the process of acquiring new understanding, knowledge, behaviors, skills, values, attitudes, and preferences. Emotional Intelligence : Measures the ability of individuals to recognize their own emotions and those of others, discern between different feelings and label them appropriately, use emotional information to guide thinking and behavior, and manage and/or adjust emotions to adapt to environments or achieve one's goals. Reasoning : Measures the capacity of consciously making sense of things, applying logic, and adapting or justifying practices, institutions, and beliefs based on new or existing information. It's associated with such characteristically human activities as philosophy, science, language, mathematics, and art. Reason is sometimes referred to as rationality. Planning : Measures the process of thinking about the activities required to achieve a desired goal. It involves the creation and maintenance of a plan, such as psychological aspects that require conceptual skills. Creativity : Measures the ability to create something new and somehow valuable. The created item may be intangible (such as an idea, a scientific theory, a musical composition, or a joke) or a physical object (such as an invention, a printed literary work, or a painting). Critical Thinking : Measures the analysis of facts to form a judgment. It's the rational, skeptical, unbiased analysis, or evaluation of facts. Critical thinking is self-directed, self-disciplined, self-monitored, and self-corrective thinking. It presupposes assent to rigorous standards of excellence and mindful command of their use. It entails effective communication and problem-solving abilities as well as a commitment to overcome native egocentrism and sociocentrism. Problem Solving : Measure the ability to use generic or ad hoc methods in an orderly manner to find solutions to problems. Memory : Measures the faculty of the brain to encode, store and retrieve over the time data or information. Self-control : Measures the ability to regulate one's emotions, thoughts, and behavior in the face of temptations and impulses. As an executive function, self-control is a cognitive process that is necessary for regulating one's behavior in order to achieve specific goals. Self-regulation, whether emotional or behavioral, is a limited resource which functions like energy. In the short term, overuse of self-control will lead to depletion. In the long term, the use of self-control can strengthen and improve over time. Wisdom : Measures the ability to think and act using knowledge, experience, understanding, common sense and insight. It's associated with attributes such as unbiased judgment, compassion, experiential self-knowledge, self-transcendence and non-attachment, and virtues such as ethics and benevolence. Charisma : Measures the force of personality, persuasiveness and leadership. Health attributes \u00b6 Health Measures the state of physical, mental and social well-being in which disease and infirmity are absent. Achieving and maintaining health is an ongoing process, shaped by both the evolution of health care knowledge and practices as well as personal strategies and organized interventions for staying healthy. Diet : Measures how much does the food you eat follow a healthy diet. A healthy diet includes a variety of foods that provide the different nutrients required by your body to keep on running. Nutrients help build and strengthen bones, muscles, and tendons and also regulate body processes. Also remember that water consumption is essential. Exercise : Measures the amount of physical fitness. It strengthens muscles and improves the cardiovascular system. Sleep : Measures the quality of your rest. Sleep is an essential component to maintaining health. Ongoing sleep deprivation causes an increased risk for some chronic health problems. In addition, sleep deprivation correlates with both increased susceptibility to illness and slower recovery times from illness. Due to the role of sleep in regulating metabolism, insufficient sleep may also play a role in weight gain. Social Support : Measures the perception and actuality that one is cared for, has assistance available from other people, and that one is part of a supportive social network. Support can come from diverse sources, such as family, friends, pets, neighbors, coworkers, organizations, etc. There are four common functions of social support: Emotional support : Measures the offering of empathy, concern, affection, love, trust, acceptance, intimacy, encouragement, or caring. It's the warmth and nurturance provided by sources of social support. Providing emotional support can let the individual know that they are valued. Tangible support : Measures the provision of financial help, material goods, or services. Also called instrumental support, this form of social support encompasses the concrete, direct ways people assist others. Informational support : Measures the provision of advice, guidance, suggestions, or useful information to someone. Where this information has the potential to help others problem-solve. Companionship support : Measures the support that gives someone a sense of social belonging, the presence of companions to engage in shared social activities. It's also referred to as esteem support or appraisal support . Cleanliness : Measures both the abstract state of being clean and free from germs, dirt, trash, or waste, and the habit of achieving and maintaining that state. Hygiene : Measures the conditions and practices that help to maintain health and prevent the spread of diseases. It includes such personal habit choices as how frequently to take a shower or bath, wash hands, trim fingernails, and wash clothes. It also includes attention to keeping surfaces in the home and workplace clean and pathogen-free. Tidyness : Measures the condition or quality of having everything ordered and arranged in the right place. Physical attributes \u00b6 Physical Energy: Measures the amount of physical work that you can do before getting fatigued. Strength : Measures the exertion of force on physical objects. Dexterity: Measuring agility, balance, accuracy, speed, coordination and reflexes. Skills \u00b6 Skills are the abilities to perform an action with determined results within a given amount of time or energy. Skills are divided into domain-general and domain-specific skills. For example, in the domain of work, some general skills would include time management, teamwork and leadership, self-motivation and others, whereas domain-specific skills would be used only for a certain job. Skills can be categorized based on the level of expertise and motivation in different phases: Student : Get the basic knowledge required to start performing the skill. Apprentice : Use the basic knowledge following specified instructions. Specialist : Use the state of the art knowledge following specified instructions. Expert : Creatively use the knowledge to resolve problems defining new instructions. Craftsman : Create new knowledge, skills, products or services. We can use a skill tree to track the evolution and visualize the dependencies between them. We can model skill decay with pattern like the space repetition, so it's cheaper to relearn, and will increase of the percent you don't forget. States \u00b6 States are conditions derived by the combination of user attribute levels. They can be used to increase or decrease the rate of consumption/gain of other user attributes. For example if you are tired, you can loose energy more quickly. Emotional states. Mental states. Physical states. Health states. Traits \u00b6 Traits are habitual patterns of behavior, thought, and emotion that define our personality. They are stable over time, differ across individuals, are consistent over situations, and influence behavior. Traits are in contrast to states, which are more transitory dispositions. People at the MIT have gathered a list of different traits . We could use traits to let the user define themselves, using it as a modifier of their attributes in contrast of what they read as normal . For example, If the user thinks they are forgetful, they will have a penalty of -X in the Memory attribute. Task model \u00b6 A task is an activity performed to achieve a goal. The process of doing a task costs us time and consumption of user attributes. In exchange, we get other user attributes and the partial or total solving of the issue. The task attributes are: Time: Measures the amount of time required to perform the task. Estimated: Measures the amount of time we think we need to do the task. Real: Measures the real time it took us to perform the task. Effectiveness : Measures the capability of solving the issue. For example we could use the following scale: 5 : Fully solve the problem in a way that it doesn't happen again. 4 : Fully Solves part of the problem in a way that it doesn't happen again. 3 : Temporarily solves the problem for a long period of time. 2 : Temporarily solves part of the problem for a long period of time. 1 : Temporarily solves the problem for a short period of time. Attribute Cost/Gain: List of user attributes that gets consumed or obtained while doing the task. The total cost/gain will be calculated as the integral of these attributes over the time. Actions \u00b6 Actions are task templates, they are meant to reduce the user attribute management in the tasks. They are defined by group of words and gather a default value of task attributes like consumed/gained attributes, project, tags and associated skills. For example, shuffle dancing, identified by the words dance shuffle can have the following attributes: Priority: 2 Estimate: 1 Physical Energy: -5 Mental Energy: +2 Vitality: +4 Tranquility: +3 Pleasure: +4 Creativity: +3 Exercise: +3 Dexterity: +2 The following skills: Dancing: Apprentice Shuffle dancing: Apprentice And belong to the project dance . Then in the future you'll only need to write pydo add dance shuffle in the park . And all the attributes will be filled for you. Problem model \u00b6 Problems in the context of task management, are situations that need attention and to be solved. Problems are solved by behaviours and tasks. Problems can be grouped through projects or tags. The tasks and behaviours related to solving the problem will inherit them. They will have the following attributes: Value: Measures the degree of importance of the problem. Priority: Measures the need to be solved earlier compared to other problems. We can model the negative effect they produce over the user by globally subtracting user attribute points or by modifying the consumption rate of these attributes associating them to states. The amount of the effect can be a function of the overdue, priority and value. The decay will start decreasing the user attributes in polinomic or exponential rate. This way we could implement a soft recurrence, as we would have a repeating task without recurrence, that will get automatically priorized due to the issue overdue, but it won't appear in the overdue task list. They can have a recurrence of type recurring or repeating. Behaviour model \u00b6 Behaviours define the ways of acting. Tasks on the other hand define the actions to achieve a goal. So dancing three times a week would be a behaviour and dance in the park would be the task. Behaviours once implemented solve problems with a low consumption of self-control, mental load or physical and mental energy. Behaviours don't affect user attributes, but can spawn tasks that do. We'll aim to have a user friendly interface to keep on track of behaviours you want to adopt or remove. There will be a priorized list of behaviours that can be linked to projects and tags. There could be an interactive command line interface to answer at the start and/or end of the day to keep track of the evolution of them. Some behaviours can be linked to tasks, so once one is started, a popup is shown with the behaviours that you want to change, once the task is completed it will ask you if you've followed the behaviour or not. How does the system work \u00b6 The user will give each task the gained/consumed user attribute values either manually or through actions. While the tasks are active and at time of completion in case they weren't activated, the integral of those attributes will be added or removed from the global user attributes. Certain states will be defined to be activated when specific attribute levels are met. These states will change the consumption or gain of attributes while they are active. Based on the current user state, tasks will be or not recommended. At anytime it can assess the attributes of the remaining tasks for the day to see if its possible to achieve them, if they are not, recommend other tasks that can improve the attribute that is making it impossible or suggest to reschedule the least important tasks. Sleeping \u00b6 The first time the program is executed in the day, it could ask you how well and how much you've slept. Sleeping is one of the main sources of restoration. Based in the answer, we will receive a different states can be defined to affect the ratios of consumption/gain and total attribute levels. We could take the baseline of sleeping well (value: 3) for 8 hours as a state without buffs and a recovery of the 100% of the attributes. If we've slept 8 hours but really well (value: 5), we could get the state of rested which can give a temporal buff of more mental and physical energy. If instead we've badly (value: 2) slept 5 hours we'd recover only the 42% of the attributes the sleep resets (5*2/8*3) and get the tired state which increases the consumption of energy. Make the task tracking easier \u00b6 Tracking the active tasks is difficult and tedious, we need to make it user friendly. Some ideas to achieve it could be: Have a command that stops tracking all the tasks when the user blocks the screen, and opens a pop-up that allows with a keystroke to keep on working on the previous task. Keep track of the context switches, so if a task has been active for 2 hours, it will ask the user if they are still working on the task, and to get a rest. Track the focus on windows to extract what are you doing. Or at least that when we open a specific program, it will automatically start tracking the related task. The idea would be to implement it through aliases in the terminal. Tracking the unentered tasks can also be difficult. To make it easier we could: When there is a big period of untracked time, ask the user what did he do in that time. This can be done at the start or end of the day so as not to be too invasive. We could have a REPL interface to easily fill untracked times. With suggestions of common tasks completed in that time. Welcome and Goodbye reports \u00b6 We could have a welcome report that shows the tasks to be done in the day, with a timeline of the ones that have an due with hour and minute, and a priorized list of the others. We could have a goodbye report that asks your evaluation of the day, behaviours questions, and shows you tomorrow's tasks. Refactor the task model into problem solving model \u00b6 The idea is to drive your task priorization through the priorization of the problems you want to solve. The workflow would be to define a problem, and then the tasks and behaviours to solve it. The advantages of this model shift can be: The change in the priority of the problems, can affect a group of related tasks and behaviours thus helping in the planning. We can measure the cost of attributes of different solutions. For example if we had the problem of keeping the dishes clean, we could compare the task washing them manually and using the washing machine. Can be an help in auto assigning task attributes. And the following disadvantages: It adds a management overload, because we'll need to create two resources (problem and solving entity) instead of just one. The disadvantages can be solved with a user friendly REPL interface. Support tasks triggers \u00b6 Create triggers for task creation and completion to be able to: Support external hooks. Affect states. Affect behaviours. Program chained tasks. Support flexible due date for tasks \u00b6 Create a flexible due, where you specify the range of time around the due date where the task can be completed. Add a REPL interface \u00b6 Create a REPL interface to manage tasks in a way that: We see the entities that match a specified filter (i.e actionable tasks or problems). By default shows the state indicator, id and description. The state indicator will be one of the following: [ ] : Open entity. [x] : Done entity. [D] : Deleted entity. [B] : Blocked entity. With j and k you are able to navigate between them, zo and zc will be used to show/hide the entity attributes and children. << and >> will make a task the sibling or child of the one above it. d will complete the task, D will delete it, o will reopen it. b will block it, then will ask the user for the reason. a will create a sibling task, s will create a subtask. e will launch an editor interface to change the entity attributes. Create a REPL interface to add a task: Will prompt for the description, once entered it will try to automatically fill up the rest of attributes through actions or the related problem. Will show the generated attributes. And ask the user which attributes they want to edit. Acting differently on the keyboard events: enter : Create the task as is. t : launch the tag edition REPL interface: a : Ask the user for the tags to introduce, with fuzzy auto suggestion and auto completion. If the tag doesn't exist suggest similar existing tags, if none exist or the user doesn't want them, ask if they are sure to add a new tag. j and k : Navigate over the existing tags. d : Delete the selected tag. p : Launch the project edition REPL interface like the tag REPL interface above. Define bindings for the rest of the attributes, perform input validation afterwards. Monica support \u00b6 Connect pydo to Monica with the idea of linking Monica activities and phone calls with pydo tasks. Context support \u00b6 Create a way to be able to define which entities belong to a context or another like work or personal , and once active it will only show the entities of that context.","title":"Future Features"},{"location":"future_features/#the-game-of-life","text":"The goal is to measure the user state to suggest which kind of task are more suitable, raise alerts when the user reaches certain mental or physical states or give insights on the evolution of the user attributes.","title":"The game of life"},{"location":"future_features/#domain-model","text":"","title":"Domain Model"},{"location":"future_features/#user-model","text":"We could model the state of a human with the following attributes groups: Mental attributes. Health attributes. Physical attributes. Skills. Traits. I've still not figured out how to vary the total attribute values over the time.","title":"User model"},{"location":"future_features/#mental-attributes","text":"Mental Energy: Measures the amount of mental work that you can do before getting fatigued. Vitality: Measures your life force of wanting to do things. For example, for me, dancing or doing work out is a task that increases my vitality, while staying in the couch for 5 hours watching tv shows kills my vitality. Tranquility : Measures the state of being calm, serene, and worry-free. As a side effect it measures the levels of stress and anxiety. Mental load : Measure of the invisible labor involved in managing yourself, a household and your closed ones, which typically falls on women's shoulders. Also sometimes referred to as worry work or cognitive labor , the mental load is about not the physical tasks but rather the overseeing of those tasks. It's being the one in charge of having the never-ending list of to-do items constantly running in your head, remembering what needs to get done and when, delegating tasks to others, and making sure they actually get done. One study describes it as the responsibility of anticipating needs, identifying options for filling them, making decisions, and monitoring progress. Pleasure : Measures the broad class of mental states that we experience as positive, enjoyable, or worth seeking. It includes more specific states such as happiness, entertainment, enjoyment, ecstasy and euphoria. Intelligence : Measures the capacity for logic, understanding, self-awareness, learning, emotional knowledge, reasoning, planning, creativity, critical thinking, and problem-solving. More generally, it's the ability to perceive or infer information, and to keep it as knowledge to be applied towards adaptive behaviors within an environment or context. Logic : Measures the systematic study of valid rules of inference, i.e. the relations that lead to the acceptance of one proposition (the conclusion) on the basis of a set of other propositions (premises). More broadly, logic is the analysis and appraisal of arguments. Understanding : Measures the psychological process related to an abstract or physical object, such as a person, situation, or message whereby one is able to think about it and use concepts to deal adequately with that object. Understanding is a relation between the knower and an object of understanding. Understanding implies abilities and dispositions in relation to an object of knowledge that are enough to support intelligent behavior. Self-awareness : Measures the experience of one's own personality or individuality. While consciousness is being aware of one's environment and body and lifestyle, self-awareness is the recognition of that awareness. Self-awareness is how an individual consciously knows and understands their own character, feelings, motives, and desires. Learning : Measures the process of acquiring new understanding, knowledge, behaviors, skills, values, attitudes, and preferences. Emotional Intelligence : Measures the ability of individuals to recognize their own emotions and those of others, discern between different feelings and label them appropriately, use emotional information to guide thinking and behavior, and manage and/or adjust emotions to adapt to environments or achieve one's goals. Reasoning : Measures the capacity of consciously making sense of things, applying logic, and adapting or justifying practices, institutions, and beliefs based on new or existing information. It's associated with such characteristically human activities as philosophy, science, language, mathematics, and art. Reason is sometimes referred to as rationality. Planning : Measures the process of thinking about the activities required to achieve a desired goal. It involves the creation and maintenance of a plan, such as psychological aspects that require conceptual skills. Creativity : Measures the ability to create something new and somehow valuable. The created item may be intangible (such as an idea, a scientific theory, a musical composition, or a joke) or a physical object (such as an invention, a printed literary work, or a painting). Critical Thinking : Measures the analysis of facts to form a judgment. It's the rational, skeptical, unbiased analysis, or evaluation of facts. Critical thinking is self-directed, self-disciplined, self-monitored, and self-corrective thinking. It presupposes assent to rigorous standards of excellence and mindful command of their use. It entails effective communication and problem-solving abilities as well as a commitment to overcome native egocentrism and sociocentrism. Problem Solving : Measure the ability to use generic or ad hoc methods in an orderly manner to find solutions to problems. Memory : Measures the faculty of the brain to encode, store and retrieve over the time data or information. Self-control : Measures the ability to regulate one's emotions, thoughts, and behavior in the face of temptations and impulses. As an executive function, self-control is a cognitive process that is necessary for regulating one's behavior in order to achieve specific goals. Self-regulation, whether emotional or behavioral, is a limited resource which functions like energy. In the short term, overuse of self-control will lead to depletion. In the long term, the use of self-control can strengthen and improve over time. Wisdom : Measures the ability to think and act using knowledge, experience, understanding, common sense and insight. It's associated with attributes such as unbiased judgment, compassion, experiential self-knowledge, self-transcendence and non-attachment, and virtues such as ethics and benevolence. Charisma : Measures the force of personality, persuasiveness and leadership.","title":"Mental attributes"},{"location":"future_features/#health-attributes","text":"Health Measures the state of physical, mental and social well-being in which disease and infirmity are absent. Achieving and maintaining health is an ongoing process, shaped by both the evolution of health care knowledge and practices as well as personal strategies and organized interventions for staying healthy. Diet : Measures how much does the food you eat follow a healthy diet. A healthy diet includes a variety of foods that provide the different nutrients required by your body to keep on running. Nutrients help build and strengthen bones, muscles, and tendons and also regulate body processes. Also remember that water consumption is essential. Exercise : Measures the amount of physical fitness. It strengthens muscles and improves the cardiovascular system. Sleep : Measures the quality of your rest. Sleep is an essential component to maintaining health. Ongoing sleep deprivation causes an increased risk for some chronic health problems. In addition, sleep deprivation correlates with both increased susceptibility to illness and slower recovery times from illness. Due to the role of sleep in regulating metabolism, insufficient sleep may also play a role in weight gain. Social Support : Measures the perception and actuality that one is cared for, has assistance available from other people, and that one is part of a supportive social network. Support can come from diverse sources, such as family, friends, pets, neighbors, coworkers, organizations, etc. There are four common functions of social support: Emotional support : Measures the offering of empathy, concern, affection, love, trust, acceptance, intimacy, encouragement, or caring. It's the warmth and nurturance provided by sources of social support. Providing emotional support can let the individual know that they are valued. Tangible support : Measures the provision of financial help, material goods, or services. Also called instrumental support, this form of social support encompasses the concrete, direct ways people assist others. Informational support : Measures the provision of advice, guidance, suggestions, or useful information to someone. Where this information has the potential to help others problem-solve. Companionship support : Measures the support that gives someone a sense of social belonging, the presence of companions to engage in shared social activities. It's also referred to as esteem support or appraisal support . Cleanliness : Measures both the abstract state of being clean and free from germs, dirt, trash, or waste, and the habit of achieving and maintaining that state. Hygiene : Measures the conditions and practices that help to maintain health and prevent the spread of diseases. It includes such personal habit choices as how frequently to take a shower or bath, wash hands, trim fingernails, and wash clothes. It also includes attention to keeping surfaces in the home and workplace clean and pathogen-free. Tidyness : Measures the condition or quality of having everything ordered and arranged in the right place.","title":"Health attributes"},{"location":"future_features/#physical-attributes","text":"Physical Energy: Measures the amount of physical work that you can do before getting fatigued. Strength : Measures the exertion of force on physical objects. Dexterity: Measuring agility, balance, accuracy, speed, coordination and reflexes.","title":"Physical attributes"},{"location":"future_features/#skills","text":"Skills are the abilities to perform an action with determined results within a given amount of time or energy. Skills are divided into domain-general and domain-specific skills. For example, in the domain of work, some general skills would include time management, teamwork and leadership, self-motivation and others, whereas domain-specific skills would be used only for a certain job. Skills can be categorized based on the level of expertise and motivation in different phases: Student : Get the basic knowledge required to start performing the skill. Apprentice : Use the basic knowledge following specified instructions. Specialist : Use the state of the art knowledge following specified instructions. Expert : Creatively use the knowledge to resolve problems defining new instructions. Craftsman : Create new knowledge, skills, products or services. We can use a skill tree to track the evolution and visualize the dependencies between them. We can model skill decay with pattern like the space repetition, so it's cheaper to relearn, and will increase of the percent you don't forget.","title":"Skills"},{"location":"future_features/#states","text":"States are conditions derived by the combination of user attribute levels. They can be used to increase or decrease the rate of consumption/gain of other user attributes. For example if you are tired, you can loose energy more quickly. Emotional states. Mental states. Physical states. Health states.","title":"States"},{"location":"future_features/#traits","text":"Traits are habitual patterns of behavior, thought, and emotion that define our personality. They are stable over time, differ across individuals, are consistent over situations, and influence behavior. Traits are in contrast to states, which are more transitory dispositions. People at the MIT have gathered a list of different traits . We could use traits to let the user define themselves, using it as a modifier of their attributes in contrast of what they read as normal . For example, If the user thinks they are forgetful, they will have a penalty of -X in the Memory attribute.","title":"Traits"},{"location":"future_features/#task-model","text":"A task is an activity performed to achieve a goal. The process of doing a task costs us time and consumption of user attributes. In exchange, we get other user attributes and the partial or total solving of the issue. The task attributes are: Time: Measures the amount of time required to perform the task. Estimated: Measures the amount of time we think we need to do the task. Real: Measures the real time it took us to perform the task. Effectiveness : Measures the capability of solving the issue. For example we could use the following scale: 5 : Fully solve the problem in a way that it doesn't happen again. 4 : Fully Solves part of the problem in a way that it doesn't happen again. 3 : Temporarily solves the problem for a long period of time. 2 : Temporarily solves part of the problem for a long period of time. 1 : Temporarily solves the problem for a short period of time. Attribute Cost/Gain: List of user attributes that gets consumed or obtained while doing the task. The total cost/gain will be calculated as the integral of these attributes over the time.","title":"Task model"},{"location":"future_features/#actions","text":"Actions are task templates, they are meant to reduce the user attribute management in the tasks. They are defined by group of words and gather a default value of task attributes like consumed/gained attributes, project, tags and associated skills. For example, shuffle dancing, identified by the words dance shuffle can have the following attributes: Priority: 2 Estimate: 1 Physical Energy: -5 Mental Energy: +2 Vitality: +4 Tranquility: +3 Pleasure: +4 Creativity: +3 Exercise: +3 Dexterity: +2 The following skills: Dancing: Apprentice Shuffle dancing: Apprentice And belong to the project dance . Then in the future you'll only need to write pydo add dance shuffle in the park . And all the attributes will be filled for you.","title":"Actions"},{"location":"future_features/#problem-model","text":"Problems in the context of task management, are situations that need attention and to be solved. Problems are solved by behaviours and tasks. Problems can be grouped through projects or tags. The tasks and behaviours related to solving the problem will inherit them. They will have the following attributes: Value: Measures the degree of importance of the problem. Priority: Measures the need to be solved earlier compared to other problems. We can model the negative effect they produce over the user by globally subtracting user attribute points or by modifying the consumption rate of these attributes associating them to states. The amount of the effect can be a function of the overdue, priority and value. The decay will start decreasing the user attributes in polinomic or exponential rate. This way we could implement a soft recurrence, as we would have a repeating task without recurrence, that will get automatically priorized due to the issue overdue, but it won't appear in the overdue task list. They can have a recurrence of type recurring or repeating.","title":"Problem model"},{"location":"future_features/#behaviour-model","text":"Behaviours define the ways of acting. Tasks on the other hand define the actions to achieve a goal. So dancing three times a week would be a behaviour and dance in the park would be the task. Behaviours once implemented solve problems with a low consumption of self-control, mental load or physical and mental energy. Behaviours don't affect user attributes, but can spawn tasks that do. We'll aim to have a user friendly interface to keep on track of behaviours you want to adopt or remove. There will be a priorized list of behaviours that can be linked to projects and tags. There could be an interactive command line interface to answer at the start and/or end of the day to keep track of the evolution of them. Some behaviours can be linked to tasks, so once one is started, a popup is shown with the behaviours that you want to change, once the task is completed it will ask you if you've followed the behaviour or not.","title":"Behaviour model"},{"location":"future_features/#how-does-the-system-work","text":"The user will give each task the gained/consumed user attribute values either manually or through actions. While the tasks are active and at time of completion in case they weren't activated, the integral of those attributes will be added or removed from the global user attributes. Certain states will be defined to be activated when specific attribute levels are met. These states will change the consumption or gain of attributes while they are active. Based on the current user state, tasks will be or not recommended. At anytime it can assess the attributes of the remaining tasks for the day to see if its possible to achieve them, if they are not, recommend other tasks that can improve the attribute that is making it impossible or suggest to reschedule the least important tasks.","title":"How does the system work"},{"location":"future_features/#sleeping","text":"The first time the program is executed in the day, it could ask you how well and how much you've slept. Sleeping is one of the main sources of restoration. Based in the answer, we will receive a different states can be defined to affect the ratios of consumption/gain and total attribute levels. We could take the baseline of sleeping well (value: 3) for 8 hours as a state without buffs and a recovery of the 100% of the attributes. If we've slept 8 hours but really well (value: 5), we could get the state of rested which can give a temporal buff of more mental and physical energy. If instead we've badly (value: 2) slept 5 hours we'd recover only the 42% of the attributes the sleep resets (5*2/8*3) and get the tired state which increases the consumption of energy.","title":"Sleeping"},{"location":"future_features/#make-the-task-tracking-easier","text":"Tracking the active tasks is difficult and tedious, we need to make it user friendly. Some ideas to achieve it could be: Have a command that stops tracking all the tasks when the user blocks the screen, and opens a pop-up that allows with a keystroke to keep on working on the previous task. Keep track of the context switches, so if a task has been active for 2 hours, it will ask the user if they are still working on the task, and to get a rest. Track the focus on windows to extract what are you doing. Or at least that when we open a specific program, it will automatically start tracking the related task. The idea would be to implement it through aliases in the terminal. Tracking the unentered tasks can also be difficult. To make it easier we could: When there is a big period of untracked time, ask the user what did he do in that time. This can be done at the start or end of the day so as not to be too invasive. We could have a REPL interface to easily fill untracked times. With suggestions of common tasks completed in that time.","title":"Make the task tracking easier"},{"location":"future_features/#welcome-and-goodbye-reports","text":"We could have a welcome report that shows the tasks to be done in the day, with a timeline of the ones that have an due with hour and minute, and a priorized list of the others. We could have a goodbye report that asks your evaluation of the day, behaviours questions, and shows you tomorrow's tasks.","title":"Welcome and Goodbye reports"},{"location":"future_features/#refactor-the-task-model-into-problem-solving-model","text":"The idea is to drive your task priorization through the priorization of the problems you want to solve. The workflow would be to define a problem, and then the tasks and behaviours to solve it. The advantages of this model shift can be: The change in the priority of the problems, can affect a group of related tasks and behaviours thus helping in the planning. We can measure the cost of attributes of different solutions. For example if we had the problem of keeping the dishes clean, we could compare the task washing them manually and using the washing machine. Can be an help in auto assigning task attributes. And the following disadvantages: It adds a management overload, because we'll need to create two resources (problem and solving entity) instead of just one. The disadvantages can be solved with a user friendly REPL interface.","title":"Refactor the task model into problem solving model"},{"location":"future_features/#support-tasks-triggers","text":"Create triggers for task creation and completion to be able to: Support external hooks. Affect states. Affect behaviours. Program chained tasks.","title":"Support tasks triggers"},{"location":"future_features/#support-flexible-due-date-for-tasks","text":"Create a flexible due, where you specify the range of time around the due date where the task can be completed.","title":"Support flexible due date for tasks"},{"location":"future_features/#add-a-repl-interface","text":"Create a REPL interface to manage tasks in a way that: We see the entities that match a specified filter (i.e actionable tasks or problems). By default shows the state indicator, id and description. The state indicator will be one of the following: [ ] : Open entity. [x] : Done entity. [D] : Deleted entity. [B] : Blocked entity. With j and k you are able to navigate between them, zo and zc will be used to show/hide the entity attributes and children. << and >> will make a task the sibling or child of the one above it. d will complete the task, D will delete it, o will reopen it. b will block it, then will ask the user for the reason. a will create a sibling task, s will create a subtask. e will launch an editor interface to change the entity attributes. Create a REPL interface to add a task: Will prompt for the description, once entered it will try to automatically fill up the rest of attributes through actions or the related problem. Will show the generated attributes. And ask the user which attributes they want to edit. Acting differently on the keyboard events: enter : Create the task as is. t : launch the tag edition REPL interface: a : Ask the user for the tags to introduce, with fuzzy auto suggestion and auto completion. If the tag doesn't exist suggest similar existing tags, if none exist or the user doesn't want them, ask if they are sure to add a new tag. j and k : Navigate over the existing tags. d : Delete the selected tag. p : Launch the project edition REPL interface like the tag REPL interface above. Define bindings for the rest of the attributes, perform input validation afterwards.","title":"Add a REPL interface"},{"location":"future_features/#monica-support","text":"Connect pydo to Monica with the idea of linking Monica activities and phone calls with pydo tasks.","title":"Monica support"},{"location":"future_features/#context-support","text":"Create a way to be able to define which entities belong to a context or another like work or personal , and once active it will only show the entities of that context.","title":"Context support"},{"location":"related/","text":"If pydo isn't your cup of tea, maybe one of the other free task managers fits the bill: Buku : Store and manage your bookmarks from the command line. CommitTasks : Combination between git commit and todo list. Eureka : CLI tool to input and store ideas without leaving the terminal. Ff : A distributed note taker and task manager. git-pending : Git plugin to list TODO, FIXME, TESTME, DOCME comments in a repository. Org mode : Notes and todo lists powered by an Emacs based plain-text system. Smos : Purely functional semantic tree-based editor (similar to [Org mode]). Taskbook : Tasks, boards & notes for the command-line habitat. Taskell : Command line Kanban board / task management. Taskwarrior : Command line task management. Tasklite : Command line tool built with Haskell and SQLite. Toodles : Project management from the TODO's in your codebase. Tracli : Command line app that tracks your time. Ultralist : Open source task management system for the command line. Unfog : A simple CLI task and time manager. Yokadi : Command line oriented, SQLite powered todo list. Eagle : Minimalistic todo app for command line.","title":"Related"},{"location":"update/","text":"To update pydo , follow the next steps: pip3 install --upgrade git+git://github.com/lyz-code/pydo pydo install It will apply all the alembic SQL migration scripts and seed the new configuration parameters.","title":"Update"},{"location":"advanced_usage/dates/","text":"A task does not require a due date, and can simply be a statement of need: pydo add Send Alice a birthday card However this is exactly the kind of task can benefit from having a due date. There are several dates that can decorate a task, each with its own meaning and effects. You can choose to use some, all or none of these, but like all pydo features, they are there in case your needs require it, but you do not pay a performance or friction penalty by not using them. The due date \u00b6 Use a optional due task attribute to specify the exact date by which a task must be completed. This corresponds to the last possible moment when the task can be considered on-time. Using our example, we can set the due date to be Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. There is also an overdue report that makes use of the OVERDUE virtual tag, to show you what is already late. If you run the calendar report, your due date will be highlighted on it. What we see here is that Taskwarrior leverages the metadata to drive various features. Several reports will sort by due date, and as we see above, a task that has a due date now belongs on your schedule. To modify the due date of a task use the mod command: pydo mod {{ task_id }} due: {{ new_due_date }} Date format \u00b6 pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the following operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Dates"},{"location":"advanced_usage/dates/#the-due-date","text":"Use a optional due task attribute to specify the exact date by which a task must be completed. This corresponds to the last possible moment when the task can be considered on-time. Using our example, we can set the due date to be Alice's birthday: pydo add Send Alice a birthday card due:2016-11-08 Now your task has an associated due date, to help you determine when you need to work on it. There is also an overdue report that makes use of the OVERDUE virtual tag, to show you what is already late. If you run the calendar report, your due date will be highlighted on it. What we see here is that Taskwarrior leverages the metadata to drive various features. Several reports will sort by due date, and as we see above, a task that has a due date now belongs on your schedule. To modify the due date of a task use the mod command: pydo mod {{ task_id }} due: {{ new_due_date }}","title":"The due date"},{"location":"advanced_usage/dates/#date-format","text":"pydo understands different ways of expressing dates. YYYY-MM-DD : Enter year, month and day. YYYY-MM-DDTHH:mm : Enter year, month, day, hour and minute. now : Current local date and time. tomorrow : Local date for tomorrow, same as now + 24h . yesterday : Local date for yesterday, same as now - 24h . monday , tuesday , ...: Local date for the specified day, after today. There is also available in the short three lettered version: mon , tue ... Combination of the following operators to specify a relative date from now : s : seconds, m : minutes. h : hours, d : days. w : weeks. mo : months. rmo : relative months. Use this if you want to set the 3 rd Friday of the month. y : years. So 1y2mo30s will set the date to now + 1 year + 2 months + 30 seconds .","title":"Date format"},{"location":"advanced_usage/estimate/","text":"The estimate optional task attribute registers how many hours do you expect to spend on a task. In the Scrum methodology, assigning time estimate to tasks is a sin. Instead they use story points , which is an dimensionless quantity to compare tasks between themselves. The advantages of using story points is that you are not commiting to do a task in a specified amount of time and that it's easier to estimate if you are going to need more or less time to do a task than an other in relative terms. Once you complete several sprints , this estimate method is said to be more accurate. I've tried using story points in the past, but I find them unintuitive and useless when trying to improve your estimations. But as the estimate keyword accepts any float, you can use it to store story points . To set the estimate of a task use the est or estimate keyword: pydo add Task that takes 5 hours to complete est:5 Right now we only use the estimate for filtering or visualization purposes. But we plan to support reports to do data analysis on the difference between the estimation and the real time required to complete the task, so as to suggest estimation improvements.","title":"Estimate"},{"location":"advanced_usage/export/","text":"Use the export command if you want to dump your database into json format. It can be useful to do migrations of database schema in SQLite as it doesn't support the alter table operation, do operations in your data that are not yet supported in pydo or if you want to extract all your information to import it in another task manager.","title":"Export"},{"location":"advanced_usage/fun/","text":"The fun optional task attribute registers how much light-hearted pleasure, enjoyment, or amusement does the execution of the task gives. As with willpower , if your tasks have this property, it can help you determine the tasks to be done during the sprint and in what order so as not to burn yourself out. To set the value of a task use the fun keyword: pydo add Go hiking fun:4 As with the priority , I use a range of values from 0 to 5 but the parameter allows any integer.","title":"Fun"},{"location":"advanced_usage/objective_value/","text":"The value optional task attribute registers how much you feel this task is going to help you achieve a specific goal. It can be associated with Scrum business value . Business value is an horrendous capitalist term with a lot of implications, therefore we've shorten it to value . If you've categorized your tasks in projects , each one probably has one or several main objectives. If your tasks have this property, it can help you priorize which ones need to be done first, or measure the difference in value between sprints. To set the value of a task use the vl or value keyword: pydo add Task that takes 5 hours to complete value:5 As with the priority , I use a range of values from 0 (it doesn't get me closer to the objective at all) to 5 (it's a critical advance towards the goal) but the parameter allows any integer.","title":"Value"},{"location":"advanced_usage/priority/","text":"The priority optional task attribute registers how urgent a task is. The parameter allows any integer, but I use from 0 (really low priority) to 5 (really high priority), being 3 the standard medium priority. To set the priority of a task use the pri or priority keyword: pydo add Task with highest priority pri:5 Right now we only use the priority for filtering or visualization purposes. But we plan to support reports that sort the tasks by their urgency . The priority will be one of the main factors to take into account.","title":"Priority"},{"location":"advanced_usage/projects/","text":"Once you feel comfortable with the basic usage of pydo , you may want to explore the different features it has to adapt it to your workflow. As the number of tasks starts to increase, it's convenient to group them together to help us with the priorization and visualization. One way of doing so is using projects. A project is an optional category that defines the purpose of a task therefore a task can only have one project . If you feel that a task might have two projects or if you have hierarchical problems with your tasks, you may want to use tags instead. For example, I'd use clean for cleaning tasks, or time_management for pydo developing tasks. To add a project to a task, use the project or pro keyword. pydo add Improve pydo documentation pro:time_management To see all the existing projects, use the projects report: pydo projects Name Tasks Description -------- ------- --------------------- None 3 Tasks without project time_management 1 To modify a task project use the mod command: pydo mod {{ task_id }} pro:new_project","title":"Projects"},{"location":"advanced_usage/recurrence/","text":"Recurrence \u00b6 Recurrence is used to create tasks periodically, such as paying the rent or mowing the lawn. There are two types of recurrence: Recurring: Task which needs to be done every specified period of time, like day, week, etc. It doesn't matter when you complete the task, the next one will be created based on the original due date. Repeating: When this task gets completed or deleted, a duplicate will be created with the specified time offset from the closing date. I.e. subsequent tasks get delayed (e.g. mowing the lawn). pydo implements recurrence with the creation of two kind of tasks: parent and children. The first one holds the template for the second. So each time a child is completed or deleted, the parent attributes are copied and the due date is set according to the recurrence type. pydo will only maintain one children per parent, so it won't create new tasks until the existent is either completed or deleted. Furthermore, it will create only the next actionable task. So if from the last completed children you've missed 3 tasks, those won't be created. Create a recurring or repeating task. \u00b6 To create a recurrent or repeating task, the recurrence time must be set under the rec or rep attribute. That attribute must match the pytho date format. pydo add Pay the rent due:1st rec:1mo pydo add Mow the lawn due:today rep:20d Once they are created, the children will show in the open report, but not the parent. $: pydo ID Title Due ---- ------------- ---------------- f Mow the lawn 2020 -05-03 14 :36 s Pay the rent 2020 -05-03 14 :29 The parent can be seen with the repeating and recurring reports. $: pydo repeating ID Title Recurrence Due ---- ------------- ------------ ---------------- d Mown the lawn 20d 2020 -05-03 14 :36 $: pydo recurring ID Title Recurrence Due ---- ------------ ------------ ---------------- a Pay the rent 1mo 2020 -05-03 14 :29 Completing or deleting a repeating task \u00b6 If you complete or delete the children of a recurrent or repeating task, the next child will be spawned. But if you wish to delete or complete the parent so no further children gets created, you can do either by calling done or del with the parent task id, or with the -p argument with the child id. The advantage of the second method is that you don't need to know the parent id, and it will close both parent and children $: pydo del -p f $: pydo ID Title Due ---- ------------ ---------------- s Pay the rent 2020 -05-03 14 :29 Modifying a recurring task \u00b6 If changes are made in a child task, those changes wont be propagated to the following children, so If you want to make changes permanent, you need to modify the parent either using the parent task id or using mod -p with the children id. Freeze a parent task \u00b6 If you need to temporary pause the creation of new children you can freeze the parent task either with it's id or with freeze -p using the children id. Frozen tasks will appear in the frozen report. To resume the children creation use the unfreeze command.","title":"Recurrence"},{"location":"advanced_usage/recurrence/#recurrence","text":"Recurrence is used to create tasks periodically, such as paying the rent or mowing the lawn. There are two types of recurrence: Recurring: Task which needs to be done every specified period of time, like day, week, etc. It doesn't matter when you complete the task, the next one will be created based on the original due date. Repeating: When this task gets completed or deleted, a duplicate will be created with the specified time offset from the closing date. I.e. subsequent tasks get delayed (e.g. mowing the lawn). pydo implements recurrence with the creation of two kind of tasks: parent and children. The first one holds the template for the second. So each time a child is completed or deleted, the parent attributes are copied and the due date is set according to the recurrence type. pydo will only maintain one children per parent, so it won't create new tasks until the existent is either completed or deleted. Furthermore, it will create only the next actionable task. So if from the last completed children you've missed 3 tasks, those won't be created.","title":"Recurrence"},{"location":"advanced_usage/recurrence/#create-a-recurring-or-repeating-task","text":"To create a recurrent or repeating task, the recurrence time must be set under the rec or rep attribute. That attribute must match the pytho date format. pydo add Pay the rent due:1st rec:1mo pydo add Mow the lawn due:today rep:20d Once they are created, the children will show in the open report, but not the parent. $: pydo ID Title Due ---- ------------- ---------------- f Mow the lawn 2020 -05-03 14 :36 s Pay the rent 2020 -05-03 14 :29 The parent can be seen with the repeating and recurring reports. $: pydo repeating ID Title Recurrence Due ---- ------------- ------------ ---------------- d Mown the lawn 20d 2020 -05-03 14 :36 $: pydo recurring ID Title Recurrence Due ---- ------------ ------------ ---------------- a Pay the rent 1mo 2020 -05-03 14 :29","title":"Create a recurring or repeating task."},{"location":"advanced_usage/recurrence/#completing-or-deleting-a-repeating-task","text":"If you complete or delete the children of a recurrent or repeating task, the next child will be spawned. But if you wish to delete or complete the parent so no further children gets created, you can do either by calling done or del with the parent task id, or with the -p argument with the child id. The advantage of the second method is that you don't need to know the parent id, and it will close both parent and children $: pydo del -p f $: pydo ID Title Due ---- ------------ ---------------- s Pay the rent 2020 -05-03 14 :29","title":"Completing or deleting a repeating task"},{"location":"advanced_usage/recurrence/#modifying-a-recurring-task","text":"If changes are made in a child task, those changes wont be propagated to the following children, so If you want to make changes permanent, you need to modify the parent either using the parent task id or using mod -p with the children id.","title":"Modifying a recurring task"},{"location":"advanced_usage/recurrence/#freeze-a-parent-task","text":"If you need to temporary pause the creation of new children you can freeze the parent task either with it's id or with freeze -p using the children id. Frozen tasks will appear in the frozen report. To resume the children creation use the unfreeze command.","title":"Freeze a parent task"},{"location":"advanced_usage/tags/","text":"Tags are the other way of clustering your tasks, unlike projects , a task can have several tags. So adding tags is the way to register that several tags share an attribute. For example, I'd use python for tasks related to developing programs with that language, or if you don't use willpower , light could be used to gather easily done tasks. To add a tag to a task, we use the +tag keyword. pydo add Fix pydo install process +python To see all the existing tags, use the tags report: pydo tags Name Tasks Description ------ ------- ------------- python 1 To add a tag to an existing task or to remove one, use the mod command. pydo mod {{ task_id }} +new_tag pydo mod {{ task_id }} -existing_tag","title":"Tags"},{"location":"advanced_usage/willpower/","text":"The willpower optional task attribute registers how much energy the execution of the task consumes. Understanding energy as physical or mental energy. For example, solving a complex programming problem, doing long boring tasks or running a marathon have high willpower value, meanwhile watering the plants, going for a walk or to the cinema have a low value. If your tasks have this property, it can help you determine the tasks to be done during the sprint and in what order so as not to burn yourself out. Or to analyze which tasks can be candidates for automation or habit building. To set the value of a task use the wp or willpower keyword: pydo add Add recurrence support to pydo willpower:4 As with the priority , I use a range of values from 0 to 5 but the parameter allows any integer.","title":"Willpower"},{"location":"developing/database_schema/","text":"The schema is defined in the models.py file through SQLAlchemy objects. To visualize the schema we've used wwwsqldesigner through their hosted instance . We load the database_schema.xml to modify it and save it back as xml in the repo.","title":"Database Schema"},{"location":"developing/fulids/","text":"One issue I had when using taskwarrior is that it uses long static UUIDs and short dynamic ids to identify the tasks. The long ones are too cumbersome to use while executing commands and the short ones change, so you may end up doing changes on the wrong task. Friendly Id's aim to solve this problem by generating unique long ids that can be shortened to the minimum amount of characters chosen from a specific set. This set was created with the intention to minimize the finger movements in the keyboard therefore improving the speed and usability. To generate id's that are going to be used in the command line, we are using a variation of the ulids . Specification \u00b6 We took the ulid definition but tweaked to specify the friendly characters. Below is the current specification of FULID. 01AN4Z07BY 79KA1307S AAAAAAA |----------| |--------| |------| Timestamp Randomness ID 48bits 9 chars 7 chars Components \u00b6 Timestamp - 48 bit integer. - UNIX-time in milliseconds. - Won't run out of space 'til the year 10889 AD. Randomness - 45 bits. - Cryptographically secure source of randomness, if possible. ID - 24 bits. - Based on a selected character set selected by the user, by default is asdfghjwer as there are ones that require less finger movement and are not forbidden by ulid. - You can define your own character set, of the length that you want. But they should not be part of the forbidden characters, which by default are ilou|&:;()<>~*@?!$#[]{}\\\\/\\'\" . Sorting \u00b6 The left-most character must be sorted first, and the right-most character sorted last (lexical order). The default ASCII character set must be used. Within the same millisecond, sort order is not guaranteed. Usage \u00b6 Create a brand new FULID. \u00b6 The timestamp value (48-bits) is from time.time() with millisecond precision. The randomness value (45-bits) is from os.urandom() . The id value (24-bits) is from a selected character set. >>> import fulid >>> fulid () . new () < fulid ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) > Create the next fulid \u00b6 >>> import fulid >>> fulid () . new ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) < fulid ( '01DWFBFPC4K8MDYBDDBAAAAAAS' ) >","title":"Friendly IDs"},{"location":"developing/fulids/#specification","text":"We took the ulid definition but tweaked to specify the friendly characters. Below is the current specification of FULID. 01AN4Z07BY 79KA1307S AAAAAAA |----------| |--------| |------| Timestamp Randomness ID 48bits 9 chars 7 chars","title":"Specification"},{"location":"developing/fulids/#components","text":"Timestamp - 48 bit integer. - UNIX-time in milliseconds. - Won't run out of space 'til the year 10889 AD. Randomness - 45 bits. - Cryptographically secure source of randomness, if possible. ID - 24 bits. - Based on a selected character set selected by the user, by default is asdfghjwer as there are ones that require less finger movement and are not forbidden by ulid. - You can define your own character set, of the length that you want. But they should not be part of the forbidden characters, which by default are ilou|&:;()<>~*@?!$#[]{}\\\\/\\'\" .","title":"Components"},{"location":"developing/fulids/#sorting","text":"The left-most character must be sorted first, and the right-most character sorted last (lexical order). The default ASCII character set must be used. Within the same millisecond, sort order is not guaranteed.","title":"Sorting"},{"location":"developing/fulids/#usage","text":"","title":"Usage"},{"location":"developing/fulids/#create-a-brand-new-fulid","text":"The timestamp value (48-bits) is from time.time() with millisecond precision. The randomness value (45-bits) is from os.urandom() . The id value (24-bits) is from a selected character set. >>> import fulid >>> fulid () . new () < fulid ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) >","title":"Create a brand new FULID."},{"location":"developing/fulids/#create-the-next-fulid","text":">>> import fulid >>> fulid () . new ( '01DWF3EZYE0ANTCMCSSAAAAAAA' ) < fulid ( '01DWFBFPC4K8MDYBDDBAAAAAAS' ) >","title":"Create the next fulid"}]}